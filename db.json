{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"f7322a1255a3ec2c0e68e3ab2172d5c46cb73588","modified":1717562789908},{"_id":"source/_drafts/websocket.md","hash":"a1c109d3dfb88e6e0403527f1b2a76fdaf49cf82","modified":1719811488353},{"_id":"source/_drafts/多线程并发同步.md","hash":"b8e28acde587dc0c00477dc3baf621bcc0d83181","modified":1719550522749},{"_id":"source/_drafts/消息队列.md","hash":"db91527001c68ddbd1abbc38d5b8af4b47c47e2c","modified":1719550878784},{"_id":"source/_drafts/音视频处理工具FFmpeg.md","hash":"dcfa7160087a7a812414a4462e8c0715e45f2901","modified":1719550263374},{"_id":"source/about/index.md","hash":"7c0b5d84a4913d88890839db0941cc61c035d004","modified":1718893936971},{"_id":"source/_posts/python转javascript学习笔记（一）.md","hash":"eb06c3a8878bb84e33d025f885d157578c4376b9","modified":1718686558206},{"_id":"source/_posts/了解cookie-session-token.md","hash":"83cf3a69bbaa8d2faadacec47ef5a2d1fa31a39c","modified":1719811859073},{"_id":"source/_posts/天气数据下载与解析.md","hash":"d43840757bc88ca10e4a33a6435685f7c9c11372","modified":1718103341507},{"_id":"source/_posts/快速搭建个人博客网站.md","hash":"32df4441fd55ac2d5363686311bb9ff406a2345e","modified":1718893567010},{"_id":"source/.obsidian/app.json","hash":"d3eaeda75a30d28065d5c7b9c870fde22edb45ab","modified":1719838571611},{"_id":"source/.obsidian/appearance.json","hash":"a4f0e406b4d4dea73186321cd7a90afda22c1875","modified":1719838571612},{"_id":"source/.obsidian/core-plugins-migration.json","hash":"f3e3d0173365389893c5ea1736c4cc28cdc59a93","modified":1717682662992},{"_id":"source/.obsidian/community-plugins.json","hash":"e8747b072a2d0d6f7d89de54e14e06a3fd674474","modified":1718774240740},{"_id":"source/.obsidian/core-plugins.json","hash":"fa1732fe2fe12b16f3062f302ac462cfa9736da1","modified":1717682662990},{"_id":"source/.obsidian/workspace.json","hash":"746f17e3109fb9b033949816c25dd98bc0cae208","modified":1719838571379},{"_id":"source/.obsidian/.DS_Store","hash":"6455e1514d48079288dc45ae0230c8136c01ce07","modified":1717306751176},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618194011460.png","hash":"0e3f4d92186414a4aafab98a53bcb16d11edef5e","modified":1718710811462},{"_id":"source/.obsidian/hotkeys.json","hash":"bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f","modified":1717304901715},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618223842003.png","hash":"662d53034b25e91f0446103ebb9c4cc6e7c7955a","modified":1718721522005},{"_id":"source/.obsidian/plugins/dataview/styles.css","hash":"0f25cdbc7448afb8326cfb53705f4b7084634cfb","modified":1718774238104},{"_id":"source/.obsidian/plugins/dataview/manifest.json","hash":"63c429659e5d71596ed822bcbe43dc7e1b064bff","modified":1718774238105},{"_id":"source/.obsidian/plugins/.DS_Store","hash":"88ce6e0f5d69496eba6ef931642edcb924828b09","modified":1717307766897},{"_id":"source/.obsidian/plugins/obsidian-admonition/data.json","hash":"98392cb9f4ec887b9e449c54c8243f52dd82a964","modified":1718710529089},{"_id":"source/.obsidian/plugins/obsidian-admonition/manifest.json","hash":"91a5dc15aa72e99c7ad38cf25f0e326cc466bd0d","modified":1718103719951},{"_id":"source/.obsidian/plugins/obsidian-admonition/styles.css","hash":"9817f240d92bf308a37918ffc89504a3637d7412","modified":1718103719949},{"_id":"source/.obsidian/plugins/obsidian-custom-attachment-location/data.json","hash":"441a25bb0a941bde91638e2209ad7e2d4ce2e373","modified":1717338356656},{"_id":"source/.obsidian/plugins/obsidian-custom-attachment-location/main.js","hash":"87b05f9b5331e59bf70c9ddae6c6feb8013f37a3","modified":1717305378333},{"_id":"source/.obsidian/plugins/obsidian-pkmer/data.json","hash":"e84da279a908b6eb9dacd418d60e792b972e4154","modified":1709193397780},{"_id":"source/.obsidian/plugins/obsidian-custom-attachment-location/manifest.json","hash":"0d61288bf5ffad24be828111f30455bbee720d12","modified":1717305378335},{"_id":"source/.obsidian/plugins/obsidian-pkmer/manifest.json","hash":"d9d73270fad3c22e35f3569cf9d757681fba413e","modified":1708613178000},{"_id":"source/.obsidian/plugins/oz-clear-unused-images/data.json","hash":"365e995aa4b644684ca9fb40158bb8e8ed445e64","modified":1718710543365},{"_id":"source/.obsidian/plugins/remotely-save/.gitignore","hash":"ec87caae87d46c7f6bce94197bc3948b83fc03d0","modified":1717307215099},{"_id":"source/.obsidian/plugins/oz-clear-unused-images/manifest.json","hash":"7b670b32ec50822280d07ca8dd7d65ea6fcae117","modified":1718710523095},{"_id":"source/.obsidian/plugins/oz-clear-unused-images/styles.css","hash":"694f91afc8815562c0ef05758991db9724da6d83","modified":1718710523093},{"_id":"source/.obsidian/plugins/oz-clear-unused-images/main.js","hash":"d10927afc485d41a5c2b4e052b44f3a9e6dc73b8","modified":1718710523091},{"_id":"source/.obsidian/plugins/remotely-save/data.json","hash":"4fa7c19c961e5286b4585bebc81485d78b9ef2b5","modified":1719811602770},{"_id":"source/.obsidian/plugins/remotely-save/manifest.json","hash":"32f02b041843bc257ea39b23abcd376680dc8ed3","modified":1717307212460},{"_id":"source/.obsidian/plugins/remotely-save/styles.css","hash":"5f57d1452fb7478e29f77d77c3a90586dd62181e","modified":1717307212445},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618210158068.png","hash":"dd36e74ac6f23e40139a7fe39654dead032e56af","modified":1718715718081},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618204259093.png","hash":"11d581f94c00028562c8921707bf0167910c6240","modified":1718714579108},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618212022198.png","hash":"c757bf943e28503bd09fb4bd41ff3b642cdd6928","modified":1718716822199},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618193622234.png","hash":"a4992724efaa6ecfc80b11aac8d63616aa12bc7c","modified":1718710582236},{"_id":"source/.obsidian/plugins/obsidian-pkmer/styles.css","hash":"31b60dbdf016e013c47eb0dc674ad59f1a825c54","modified":1708613178000},{"_id":"source/.trash/image-20240618193114230.png","hash":"015fa0f4e009501dd870c1a43845a9d4fd15ffe6","modified":1718710274246},{"_id":"source/_drafts/websocket/image-20240701131705543.png","hash":"cd34ce0aa4874f9d6a0e3068ee8caa6e1c847e17","modified":1719811025545},{"_id":"source/_posts/了解cookie-session-token/image-20240701133048798.png","hash":"b7425c65c5c2e94e919d37b5e7d7836807be660f","modified":1719811848801},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618211935184.png","hash":"7fdc31c9a92c176ba826224f1ef6fc1db9d4c6ee","modified":1718716775192},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618212206448.png","hash":"049ab67c525aa91ed078c7a18cf1c4e63948dcc5","modified":1718716926451},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618212413299.png","hash":"19b1b4c5003af3cd38894244d732152790590dbd","modified":1718717053303},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618223151710.png","hash":"98d7c19449c04c0211e99f1d79729c51411978a0","modified":1718721111725},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618212640334.png","hash":"d2f954c4dfc3bc9670a29aaa88ad50a264bceada","modified":1718717200338},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618222851091.png","hash":"f26859617c1b465f676c29a1ab2bd6436947b928","modified":1718720931093},{"_id":"source/_drafts/音视频处理工具FFmpeg/image-20240626203519362.png","hash":"f3c778c87ace9120254253d2bed1f076a114aa14","modified":1719405319364},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1717305035039},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618212456346.png","hash":"0640096733ad4c59adc1067b493014a382d37cbf","modified":1718717096348},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"759d78d97cfe364a4bcf0b5cd2d3505967674276","modified":1717305035040},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"c640b57695b7b6002399711f1a7708b0f6c05b84","modified":1717305035025},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1717305034893},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1717305034892},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1717305034920},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1717305034923},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1717305034924},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1717305035006},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"33c3317cdcee062789de2336dd8d0cc7f86d3650","modified":1717305035006},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"ff9b0e1fb9dba665af2f1e4a577f8cb9e840464b","modified":1717305035026},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1717305034889},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1717305035006},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1717305035009},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"9bf0d357a607a282f3b9cb04525a4df0cc2a8b76","modified":1717305035010},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1717305035012},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1717305035040},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1717305035041},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1717305035012},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1717305035041},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1717305035041},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1717305035041},{"_id":"node_modules/hexo-theme-fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1717305035041},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"2253e1bc61694b3bdc5e434ea2660d13d941b50e","modified":1717305035041},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1717305035042},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1717305035042},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1717305034920},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1717305034924},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1717305034923},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1717305034925},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1717305034925},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1717305034965},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1717305034966},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1717305034967},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1717305035007},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1717305035009},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1717305035021},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1717305035017},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1717305035010},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1717305035023},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1717305035011},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"82bb06686158ebe160a631c79f156cd4fde35656","modified":1717305035024},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1717305035023},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1717305035020},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1717305035017},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1717305035024},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1717305035019},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1717305035017},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1717305035018},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1717305035022},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1717305035024},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1717305035024},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1717305035025},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"4d48c424e47ff9a17a563167ea5f480890267adf","modified":1717305035025},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1717305035014},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"966689d7c5e4320008285395fbaa2751f6209be5","modified":1717305035025},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/fold.js","hash":"73e4fd12ce3e47981479391ed354b7d9d3279f70","modified":1717305035018},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1717305035019},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1717305035022},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"0857aa86db2a711ae5c77218a9e3fa686d0e87b1","modified":1717305035015},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1717305035024},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1717305035024},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1717305035024},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1717305035024},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1717305035015},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/crypto.js","hash":"ae4ad8a188ef5b3fa6818b01629fc962b3de8551","modified":1717305035016},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1717305035025},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1717305034891},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1717305035036},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1717305035035},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1717305035026},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1717305035034},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1717305035013},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1717305035014},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1717305035028},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1717305035028},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"c5939d14065d38c86e16d1642e154dde5a23e830","modified":1717305035015},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1717305035019},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1717305035023},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"5891534506b959a2f559f29e122baa3eb9159d93","modified":1717305035018},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1717305035022},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1717305035024},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1717305035025},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1717305034926},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1717305035040},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1717305034926},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1717305034924},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1717305034926},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1717305034964},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1717305034964},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1717305035010},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1717305035007},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1717305035012},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1717305035013},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1717305034922},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1717305035013},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1717305035013},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1717305035012},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1717305034921},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"4f68c80bd1395e2f6d11e373116e54de11cb62e8","modified":1717305034894},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"37d750428772d7c71ba36ce0c2540780d90fadea","modified":1717305035009},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1717305034896},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1717305034925},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1717305034926},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1717305035007},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1717305035005},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1717305034927},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1717305035008},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/moment.ejs","hash":"4ff3fb1b60ccc95a0af3bbdbd0757fedefc088b5","modified":1717305035009},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1717305034923},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"529f3069742b3d338c769ba2d836e7f3c342a09d","modified":1717305034925},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1717305035012},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1717305035009},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1717305035009},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1717305035008},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1717305035011},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1717305035011},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1717305035016},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"bd8376e1cf7892dc2daa58f2f443574be559fdbf","modified":1717305035019},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1717305035012},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"a5fe1deccb73b5f578797dbb11038efc15f63ce8","modified":1717305035019},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"c19ac8050b82c3676b0332a56099ccfcc36d9d52","modified":1717305035018},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1717305035021},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1717305035022},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1717305035023},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1717305035031},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1717305035031},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1717305035037},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1717305035032},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1717305035030},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1717305035029},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1717305035032},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"85492ef64d7e5f70f0f7e46d570bbc911e686d7e","modified":1717305035033},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1717305035036},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1717305035035},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1717305035038},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1717305035033},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1717305035033},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1717305035033},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1717305035036},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"25fb6fa4c783b847c632584c49a7e1593cdb2f5d","modified":1717305035035},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1717305035036},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1717305035035},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"cd432a6411ccac7df47e6a300fb1a872cfc763e7","modified":1717305035038},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1717305035034},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"c96d36aa8fe20f0c3c1a29ee2473cd8064b10f73","modified":1717305035038},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1717305035039},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1717305035030},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1717305035030},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1717305035034},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1717305035032},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1717305035033},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":1717305035034},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1717305035034},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1717305035034},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1717305035037},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1717305035037},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1717305035037},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1717305035038},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1717305035038},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1717305035037},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1717305035039},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1717305035039},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1717305035027},{"_id":"source/.obsidian/plugins/obsidian-admonition/main.js","hash":"3e16a272371d452f3b18e6ddd63f7b9faf957f8e","modified":1718103719948},{"_id":"source/.obsidian/plugins/obsidian-pkmer/main.js","hash":"8adf46327d7d51d06d06c249f6bc1167b5da4e8a","modified":1708613178000},{"_id":"source/.obsidian/plugins/remotely-save/main.js","hash":"a16b1fc2b23294f91910377ddd8276307e925024","modified":1717307212443},{"_id":"source/.obsidian/plugins/dataview/main.js","hash":"c794db975cb80c207e6c2c48e8626c0d10c9d3b0","modified":1718774238102},{"_id":"public/local-search.xml","hash":"43b3e35d086d35e71bc14acc4e8e93af87fa424a","modified":1719838582573},{"_id":"public/about/index.html","hash":"4087534648fb00e24aba9e19aca5279f7d35372a","modified":1719838582573},{"_id":"public/2024/07/01/了解cookie-session-token/index.html","hash":"f960ae423a8975adec19e805d7c8a8ac1806ac84","modified":1719838582573},{"_id":"public/2024/06/18/快速搭建个人博客网站/index.html","hash":"e7a3ec938c36bf304d7aa2c64d9656c1516e989b","modified":1719838582573},{"_id":"public/2024/06/18/python转javascript学习笔记（一）/index.html","hash":"ba06ab1bde73ec9600dc1a57dd6f87c532c02218","modified":1719838582573},{"_id":"public/2024/06/10/天气数据下载与解析/index.html","hash":"4659019b273b8f880353ba66ec3838823d61f9d9","modified":1719838582573},{"_id":"public/archives/2024/index.html","hash":"0ae36866c58a0e8900603e943eb2eccc4c40db7e","modified":1719838582573},{"_id":"public/archives/2024/06/index.html","hash":"bda9a30b6c8fd4ad98e3974d65fb46525a119ac2","modified":1719838582573},{"_id":"public/archives/index.html","hash":"2f6e77b18ac9e608e6854c766fcb34280b408e42","modified":1719838582573},{"_id":"public/archives/2024/07/index.html","hash":"64d5f39fed549a2fc87d90861d2b0e8a2b3f040e","modified":1719838582573},{"_id":"public/index.html","hash":"08de3546fb981fb6ba7a3ec4b38f4691f62556cf","modified":1719838582573},{"_id":"public/tags/javascript-python-单线程-异步/index.html","hash":"f816c801893c201a6c205e49095ae039850b25df","modified":1719838582573},{"_id":"public/tags/web/index.html","hash":"33d24e28effe0ce5ed26cb253ace9ddf91df56b5","modified":1719838582573},{"_id":"public/tags/gis/index.html","hash":"05c92efd103e025dc3d9af50912a45eabfd70763","modified":1719838582573},{"_id":"public/tags/python/index.html","hash":"5a209acfb09759833fd8ea77c8937ba24eb69a99","modified":1719838582573},{"_id":"public/tags/git-obsidian-hexo-fluid/index.html","hash":"d812056cb6c2b3d9b0d1e9ae541451f0520dcd45","modified":1719838582573},{"_id":"public/404.html","hash":"5c1a56061b120406ff63f2a1a8b28e0d2f856ba9","modified":1719838582573},{"_id":"public/tags/index.html","hash":"789720f75851e8a6efb4a50bb5ede90335a53cc7","modified":1719838582573},{"_id":"public/categories/index.html","hash":"1ed07ccaf94945f1cfcef73a689e0897011a4283","modified":1719838582573},{"_id":"public/links/index.html","hash":"b6172ed0e034fdc98e96effa5400917029682b28","modified":1719838582573},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1719838582573},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1719838582573},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1719838582573},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1719838582573},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1719838582573},{"_id":"public/2024/06/18/快速搭建个人博客网站/image-20240618194011460.png","hash":"0e3f4d92186414a4aafab98a53bcb16d11edef5e","modified":1719838582573},{"_id":"public/2024/06/18/快速搭建个人博客网站/image-20240618223842003.png","hash":"662d53034b25e91f0446103ebb9c4cc6e7c7955a","modified":1719838582573},{"_id":"public/2024/06/18/快速搭建个人博客网站/image-20240618210158068.png","hash":"dd36e74ac6f23e40139a7fe39654dead032e56af","modified":1719838582573},{"_id":"public/2024/06/18/快速搭建个人博客网站/image-20240618212022198.png","hash":"c757bf943e28503bd09fb4bd41ff3b642cdd6928","modified":1719838582573},{"_id":"public/2024/06/18/快速搭建个人博客网站/image-20240618204259093.png","hash":"11d581f94c00028562c8921707bf0167910c6240","modified":1719838582573},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1719838582573},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1719838582573},{"_id":"public/css/highlight-dark.css","hash":"902294bada4323c0f51502d67cba8c3a0298952f","modified":1719838582573},{"_id":"public/css/main.css","hash":"7d7590cfe0261084ad357d5f51cb14d13db826d8","modified":1719838582573},{"_id":"public/js/color-schema.js","hash":"c5939d14065d38c86e16d1642e154dde5a23e830","modified":1719838582573},{"_id":"public/css/highlight.css","hash":"04d4ddbb5e1d1007447c2fe293ee05aae9b9563e","modified":1719838582573},{"_id":"public/js/events.js","hash":"5891534506b959a2f559f29e122baa3eb9159d93","modified":1719838582573},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1719838582573},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1719838582573},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1719838582573},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1719838582573},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1719838582573},{"_id":"public/2024/06/18/快速搭建个人博客网站/image-20240618193622234.png","hash":"a4992724efaa6ecfc80b11aac8d63616aa12bc7c","modified":1719838582573},{"_id":"public/2024/07/01/了解cookie-session-token/image-20240701133048798.png","hash":"b7425c65c5c2e94e919d37b5e7d7836807be660f","modified":1719838582573},{"_id":"public/2024/06/18/快速搭建个人博客网站/image-20240618211935184.png","hash":"7fdc31c9a92c176ba826224f1ef6fc1db9d4c6ee","modified":1719838582573},{"_id":"public/2024/06/18/快速搭建个人博客网站/image-20240618212206448.png","hash":"049ab67c525aa91ed078c7a18cf1c4e63948dcc5","modified":1719838582573},{"_id":"public/2024/06/18/快速搭建个人博客网站/image-20240618212413299.png","hash":"19b1b4c5003af3cd38894244d732152790590dbd","modified":1719838582573},{"_id":"public/2024/06/18/快速搭建个人博客网站/image-20240618223151710.png","hash":"98d7c19449c04c0211e99f1d79729c51411978a0","modified":1719838582573},{"_id":"public/2024/06/18/快速搭建个人博客网站/image-20240618212640334.png","hash":"d2f954c4dfc3bc9670a29aaa88ad50a264bceada","modified":1719838582573},{"_id":"public/2024/06/18/快速搭建个人博客网站/image-20240618222851091.png","hash":"f26859617c1b465f676c29a1ab2bd6436947b928","modified":1719838582573},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1719838582573},{"_id":"public/2024/06/18/快速搭建个人博客网站/image-20240618212456346.png","hash":"0640096733ad4c59adc1067b493014a382d37cbf","modified":1719838582573}],"Category":[],"Data":[],"Page":[{"title":"关于我","layout":"about","date":"2024-06-02T05:12:28.000Z","_content":"\n你好，我是羽飞Lexie，欢迎来到我的博客！\n\n在这里，我会持续发布一些我个人的所知所行所思所悟，分享看过的书、走过的路、踩过的坑，内容包括但不限于：\n\n- 技术开发经验 算法代码学习笔记；\n- 书影音随笔；\n- 工作学习生活感悟，探索如何「自由地活在当下」；\n\n关于本站点的搭建过程，记录在[这篇博客](https://lexieisfree.github.io/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/)\n\n最后，感谢你的阅读，期待与你一起知行合一、向上生长。","source":"about/index.md","raw":"---\ntitle: 关于我\nlayout: about\ndate: 2024-06-02 13:12:28\n---\n\n你好，我是羽飞Lexie，欢迎来到我的博客！\n\n在这里，我会持续发布一些我个人的所知所行所思所悟，分享看过的书、走过的路、踩过的坑，内容包括但不限于：\n\n- 技术开发经验 算法代码学习笔记；\n- 书影音随笔；\n- 工作学习生活感悟，探索如何「自由地活在当下」；\n\n关于本站点的搭建过程，记录在[这篇博客](https://lexieisfree.github.io/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/)\n\n最后，感谢你的阅读，期待与你一起知行合一、向上生长。","updated":"2024-06-20T14:32:16.971Z","path":"about/index.html","comments":1,"_id":"cly2zhjms0000xdqr8i6k1xrx","content":"<p>你好，我是羽飞Lexie，欢迎来到我的博客！</p>\n<p>在这里，我会持续发布一些我个人的所知所行所思所悟，分享看过的书、走过的路、踩过的坑，内容包括但不限于：</p>\n<ul>\n<li>技术开发经验 算法代码学习笔记；</li>\n<li>书影音随笔；</li>\n<li>工作学习生活感悟，探索如何「自由地活在当下」；</li>\n</ul>\n<p>关于本站点的搭建过程，记录在<a href=\"https://lexieisfree.github.io/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/\">这篇博客</a></p>\n<p>最后，感谢你的阅读，期待与你一起知行合一、向上生长。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>你好，我是羽飞Lexie，欢迎来到我的博客！</p>\n<p>在这里，我会持续发布一些我个人的所知所行所思所悟，分享看过的书、走过的路、踩过的坑，内容包括但不限于：</p>\n<ul>\n<li>技术开发经验 算法代码学习笔记；</li>\n<li>书影音随笔；</li>\n<li>工作学习生活感悟，探索如何「自由地活在当下」；</li>\n</ul>\n<p>关于本站点的搭建过程，记录在<a href=\"https://lexieisfree.github.io/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/\">这篇博客</a></p>\n<p>最后，感谢你的阅读，期待与你一起知行合一、向上生长。</p>\n"}],"Post":[{"title":"websocket","_content":"\n![](image-20240701131705543.png)\nwebsocket和http都是用tcp协议。\n\n\n# Reference\nhttps://www.bilibili.com/video/BV1ac411c7vr 心跳机制\nhttps://www.bilibili.com/video/BV19N411474y","source":"_drafts/websocket.md","raw":"---\ntitle: websocket\ntags:\n---\n\n![](image-20240701131705543.png)\nwebsocket和http都是用tcp协议。\n\n\n# Reference\nhttps://www.bilibili.com/video/BV1ac411c7vr 心跳机制\nhttps://www.bilibili.com/video/BV19N411474y","slug":"websocket","published":0,"date":"2024-07-01T05:16:58.637Z","updated":"2024-07-01T05:24:48.353Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly2zhjmv0001xdqr4dn60sr1","content":"<p><img src=\"/image-20240701131705543.png\"><br>websocket和http都是用tcp协议。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"https://www.bilibili.com/video/BV1ac411c7vr\">https://www.bilibili.com/video/BV1ac411c7vr</a> 心跳机制<br><a href=\"https://www.bilibili.com/video/BV19N411474y\">https://www.bilibili.com/video/BV19N411474y</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/image-20240701131705543.png\"><br>websocket和http都是用tcp协议。</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"https://www.bilibili.com/video/BV1ac411c7vr\">https://www.bilibili.com/video/BV1ac411c7vr</a> 心跳机制<br><a href=\"https://www.bilibili.com/video/BV19N411474y\">https://www.bilibili.com/video/BV19N411474y</a></p>\n"},{"title":"多线程并发同步","_content":"\n\n# Reference\nhttps://www.bilibili.com/video/BV1oQ4y1C73G\nhttps://www.bilibili.com/video/BV17V411e7Ua\n","source":"_drafts/多线程并发同步.md","raw":"---\ntitle: 多线程并发同步\ntags:\n---\n\n\n# Reference\nhttps://www.bilibili.com/video/BV1oQ4y1C73G\nhttps://www.bilibili.com/video/BV17V411e7Ua\n","slug":"多线程并发同步","published":0,"date":"2024-06-28T04:54:34.730Z","updated":"2024-06-28T04:55:22.749Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly2zhjmx0002xdqr4aqi5595","content":"<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"https://www.bilibili.com/video/BV1oQ4y1C73G\">https://www.bilibili.com/video/BV1oQ4y1C73G</a><br><a href=\"https://www.bilibili.com/video/BV17V411e7Ua\">https://www.bilibili.com/video/BV17V411e7Ua</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"https://www.bilibili.com/video/BV1oQ4y1C73G\">https://www.bilibili.com/video/BV1oQ4y1C73G</a><br><a href=\"https://www.bilibili.com/video/BV17V411e7Ua\">https://www.bilibili.com/video/BV17V411e7Ua</a></p>\n"},{"title":"消息队列","_content":"云原生分布式消息流平台\n\n# Reference\n[面试官：请你重构 Kafka... - labuladong - 博客园 (cnblogs.com)](https://www.cnblogs.com/labuladong/p/17023978.html)","source":"_drafts/消息队列.md","raw":"---\ntitle: 消息队列\ntags:\n  - kafka\n  - 系统架构\n---\n云原生分布式消息流平台\n\n# Reference\n[面试官：请你重构 Kafka... - labuladong - 博客园 (cnblogs.com)](https://www.cnblogs.com/labuladong/p/17023978.html)","slug":"消息队列","published":0,"date":"2024-06-28T04:58:55.901Z","updated":"2024-06-28T05:01:18.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly2zhjmy0003xdqr6lyj1pm0","content":"<p>云原生分布式消息流平台</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"https://www.cnblogs.com/labuladong/p/17023978.html\">面试官：请你重构 Kafka… - labuladong - 博客园 (cnblogs.com)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>云原生分布式消息流平台</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p><a href=\"https://www.cnblogs.com/labuladong/p/17023978.html\">面试官：请你重构 Kafka… - labuladong - 博客园 (cnblogs.com)</a></p>\n"},{"title":"音视频处理工具FFmpeg","_content":"\n# ffmpeg功能简介\nffmpeg是最强大的音视频处理工具（没有之一），可以实现视频转码、压缩、音频处理、格式转换、视频缩略图、添加水印滤镜、录频等等。ffmpeg由一位俄罗斯程序员编写（歪个题，俄罗斯程序员里牛人好多，想到了clickhouse、sci-hub、nginx），完全免费，支持在Linux/MacOS/Windows多平台运行。本身是一个命令行工具，因此可以**在脚本中方便地调用**，进行批量化自动处理，很多视频工具、平台、播放器都是使用到了ffmpeg或者它的核心库。\n\n# 下载安装\n- windows安装\n官网下载安装包：[Download FFmpeg](https://ffmpeg.org/download.html) \n![](image-20240626203519362.png)\n点击进入下载`ffmpeg-git-full.7z`，使用7zip解压。\n解压后将ffmpeg.exe所在目录添加到环境变量。\n- linux平台使用包管理工具安装\n```bash\nsudo apt install ffmpeg -y\n```\n- macOs使用Homebrew安装\n```bash\nbrew install ffmpeg\n```\n\n修改brew镜像源可参考本篇视频 https://www.bilibili.com/video/BV1ig4y1w7o6\n\n安装完成后，在终端中输入`ffmpeg -version`来确认FFmpeg已经成功安装，并查看其版本信息。\n\n# 基本使用\n官方使用文档：[ffmpeg Documentation](https://ffmpeg.org/ffmpeg.html)\n视频文件封装/容器格式一般包含：音频流、视频流、字幕、元数据等\n对于MP4文件，目前最常用的编码（将视频文件转换为二进制文件）格式为H.264/AVC/MPEG-4 Part 10。还有更高压缩率的H.265和\bVP9。\n\n- 视频编码\n```bash\n#使用ffmpeg将avi视频编码为mp4\nffmpeg -i input.avi -c:v libx264 output.mp4\n#使用英伟达显卡加速编码\nffmpeg -i input.avi -c:v h264_nvenc output.mp4\n#通过预设压缩视频大小，选项：ultrafast/superfast/veryfast/\nffmpeg -i input.avi -c:v libx264 -preset xxx output.mp4\n```\n`-i`指定输入，`-c:v`指定视频编码器(video encoder)，libx264是ffmpeg默认提供的h264视频编码器。\n- 转换音频\n```\nffmpeg -i input.wav output.mp3\n```\n\n\n\n# 参考资料\nhttps://www.bilibili.com/video/BV1AT411J7cH\n\n\n\n","source":"_drafts/音视频处理工具FFmpeg.md","raw":"---\ntitle: 音视频处理工具FFmpeg\ntags:\n  - ffmpeg\n---\n\n# ffmpeg功能简介\nffmpeg是最强大的音视频处理工具（没有之一），可以实现视频转码、压缩、音频处理、格式转换、视频缩略图、添加水印滤镜、录频等等。ffmpeg由一位俄罗斯程序员编写（歪个题，俄罗斯程序员里牛人好多，想到了clickhouse、sci-hub、nginx），完全免费，支持在Linux/MacOS/Windows多平台运行。本身是一个命令行工具，因此可以**在脚本中方便地调用**，进行批量化自动处理，很多视频工具、平台、播放器都是使用到了ffmpeg或者它的核心库。\n\n# 下载安装\n- windows安装\n官网下载安装包：[Download FFmpeg](https://ffmpeg.org/download.html) \n![](image-20240626203519362.png)\n点击进入下载`ffmpeg-git-full.7z`，使用7zip解压。\n解压后将ffmpeg.exe所在目录添加到环境变量。\n- linux平台使用包管理工具安装\n```bash\nsudo apt install ffmpeg -y\n```\n- macOs使用Homebrew安装\n```bash\nbrew install ffmpeg\n```\n\n修改brew镜像源可参考本篇视频 https://www.bilibili.com/video/BV1ig4y1w7o6\n\n安装完成后，在终端中输入`ffmpeg -version`来确认FFmpeg已经成功安装，并查看其版本信息。\n\n# 基本使用\n官方使用文档：[ffmpeg Documentation](https://ffmpeg.org/ffmpeg.html)\n视频文件封装/容器格式一般包含：音频流、视频流、字幕、元数据等\n对于MP4文件，目前最常用的编码（将视频文件转换为二进制文件）格式为H.264/AVC/MPEG-4 Part 10。还有更高压缩率的H.265和\bVP9。\n\n- 视频编码\n```bash\n#使用ffmpeg将avi视频编码为mp4\nffmpeg -i input.avi -c:v libx264 output.mp4\n#使用英伟达显卡加速编码\nffmpeg -i input.avi -c:v h264_nvenc output.mp4\n#通过预设压缩视频大小，选项：ultrafast/superfast/veryfast/\nffmpeg -i input.avi -c:v libx264 -preset xxx output.mp4\n```\n`-i`指定输入，`-c:v`指定视频编码器(video encoder)，libx264是ffmpeg默认提供的h264视频编码器。\n- 转换音频\n```\nffmpeg -i input.wav output.mp3\n```\n\n\n\n# 参考资料\nhttps://www.bilibili.com/video/BV1AT411J7cH\n\n\n\n","slug":"音视频处理工具FFmpeg","published":0,"date":"2024-06-19T04:46:31.250Z","updated":"2024-06-28T04:51:03.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly2zhjmz0004xdqrfeor4dvb","content":"<h1 id=\"ffmpeg功能简介\"><a href=\"#ffmpeg功能简介\" class=\"headerlink\" title=\"ffmpeg功能简介\"></a>ffmpeg功能简介</h1><p>ffmpeg是最强大的音视频处理工具（没有之一），可以实现视频转码、压缩、音频处理、格式转换、视频缩略图、添加水印滤镜、录频等等。ffmpeg由一位俄罗斯程序员编写（歪个题，俄罗斯程序员里牛人好多，想到了clickhouse、sci-hub、nginx），完全免费，支持在Linux&#x2F;MacOS&#x2F;Windows多平台运行。本身是一个命令行工具，因此可以<strong>在脚本中方便地调用</strong>，进行批量化自动处理，很多视频工具、平台、播放器都是使用到了ffmpeg或者它的核心库。</p>\n<h1 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h1><ul>\n<li>windows安装<br>官网下载安装包：<a href=\"https://ffmpeg.org/download.html\">Download FFmpeg</a><br><img src=\"/image-20240626203519362.png\"><br>点击进入下载<code>ffmpeg-git-full.7z</code>，使用7zip解压。<br>解压后将ffmpeg.exe所在目录添加到环境变量。</li>\n<li>linux平台使用包管理工具安装<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sudo apt install ffmpeg -y<br></code></pre></td></tr></table></figure></li>\n<li>macOs使用Homebrew安装<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">brew install ffmpeg<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>修改brew镜像源可参考本篇视频 <a href=\"https://www.bilibili.com/video/BV1ig4y1w7o6\">https://www.bilibili.com/video/BV1ig4y1w7o6</a></p>\n<p>安装完成后，在终端中输入<code>ffmpeg -version</code>来确认FFmpeg已经成功安装，并查看其版本信息。</p>\n<h1 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h1><p>官方使用文档：<a href=\"https://ffmpeg.org/ffmpeg.html\">ffmpeg Documentation</a><br>视频文件封装&#x2F;容器格式一般包含：音频流、视频流、字幕、元数据等<br>对于MP4文件，目前最常用的编码（将视频文件转换为二进制文件）格式为H.264&#x2F;AVC&#x2F;MPEG-4 Part 10。还有更高压缩率的H.265和\bVP9。</p>\n<ul>\n<li>视频编码<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#使用ffmpeg将avi视频编码为mp4</span><br>ffmpeg -i input.avi -c:v libx264 output.mp4<br><span class=\"hljs-comment\">#使用英伟达显卡加速编码</span><br>ffmpeg -i input.avi -c:v h264_nvenc output.mp4<br><span class=\"hljs-comment\">#通过预设压缩视频大小，选项：ultrafast/superfast/veryfast/</span><br>ffmpeg -i input.avi -c:v libx264 -preset xxx output.mp4<br></code></pre></td></tr></table></figure>\n<code>-i</code>指定输入，<code>-c:v</code>指定视频编码器(video encoder)，libx264是ffmpeg默认提供的h264视频编码器。</li>\n<li>转换音频<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">ffmpeg -<span class=\"hljs-selector-tag\">i</span> <span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-class\">.wav</span> output.mp3<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://www.bilibili.com/video/BV1AT411J7cH\">https://www.bilibili.com/video/BV1AT411J7cH</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ffmpeg功能简介\"><a href=\"#ffmpeg功能简介\" class=\"headerlink\" title=\"ffmpeg功能简介\"></a>ffmpeg功能简介</h1><p>ffmpeg是最强大的音视频处理工具（没有之一），可以实现视频转码、压缩、音频处理、格式转换、视频缩略图、添加水印滤镜、录频等等。ffmpeg由一位俄罗斯程序员编写（歪个题，俄罗斯程序员里牛人好多，想到了clickhouse、sci-hub、nginx），完全免费，支持在Linux&#x2F;MacOS&#x2F;Windows多平台运行。本身是一个命令行工具，因此可以<strong>在脚本中方便地调用</strong>，进行批量化自动处理，很多视频工具、平台、播放器都是使用到了ffmpeg或者它的核心库。</p>\n<h1 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h1><ul>\n<li>windows安装<br>官网下载安装包：<a href=\"https://ffmpeg.org/download.html\">Download FFmpeg</a><br><img src=\"/image-20240626203519362.png\"><br>点击进入下载<code>ffmpeg-git-full.7z</code>，使用7zip解压。<br>解压后将ffmpeg.exe所在目录添加到环境变量。</li>\n<li>linux平台使用包管理工具安装<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sudo apt install ffmpeg -y<br></code></pre></td></tr></table></figure></li>\n<li>macOs使用Homebrew安装<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">brew install ffmpeg<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>修改brew镜像源可参考本篇视频 <a href=\"https://www.bilibili.com/video/BV1ig4y1w7o6\">https://www.bilibili.com/video/BV1ig4y1w7o6</a></p>\n<p>安装完成后，在终端中输入<code>ffmpeg -version</code>来确认FFmpeg已经成功安装，并查看其版本信息。</p>\n<h1 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h1><p>官方使用文档：<a href=\"https://ffmpeg.org/ffmpeg.html\">ffmpeg Documentation</a><br>视频文件封装&#x2F;容器格式一般包含：音频流、视频流、字幕、元数据等<br>对于MP4文件，目前最常用的编码（将视频文件转换为二进制文件）格式为H.264&#x2F;AVC&#x2F;MPEG-4 Part 10。还有更高压缩率的H.265和\bVP9。</p>\n<ul>\n<li>视频编码<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#使用ffmpeg将avi视频编码为mp4</span><br>ffmpeg -i input.avi -c:v libx264 output.mp4<br><span class=\"hljs-comment\">#使用英伟达显卡加速编码</span><br>ffmpeg -i input.avi -c:v h264_nvenc output.mp4<br><span class=\"hljs-comment\">#通过预设压缩视频大小，选项：ultrafast/superfast/veryfast/</span><br>ffmpeg -i input.avi -c:v libx264 -preset xxx output.mp4<br></code></pre></td></tr></table></figure>\n<code>-i</code>指定输入，<code>-c:v</code>指定视频编码器(video encoder)，libx264是ffmpeg默认提供的h264视频编码器。</li>\n<li>转换音频<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">ffmpeg -<span class=\"hljs-selector-tag\">i</span> <span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-class\">.wav</span> output.mp3<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://www.bilibili.com/video/BV1AT411J7cH\">https://www.bilibili.com/video/BV1AT411J7cH</a></p>\n"},{"title":"python转javascript学习笔记（一）","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2024-06-18T04:39:30.000Z","password":null,"summary":null,"_content":"\n# JavaScript简介\n## 语言规范\nJavaScript语言遵循ECMAScript规范（简称ES），ECMA即欧洲计算机协会，该规范定义了JavaScript（以下统一使用js缩写）语言的核心特性，确保不同环境下的js实现（比如浏览器内置js引擎、Nodejs、其他服务器端js运行时等）的一致性和互操作性。ES6或ES2015（2015年6月发行）是该规范发行以来的一个重要里程碑，也是主流浏览器基本支持的版本。\n\n## 特性和应用场景\n1. 基于原型的面向对象语言，在动态修改和扩展对象上更加灵活（弱化了结构和可维护性）。\n- 与传统的面向对象编程范式（Java/C++/C#等）的主要区别：\n\t- 创建机制：创建对象时，无需定义类模板，通过从对已有对象的克隆或引用创建；\n\t- 继承机制：直接从原型对象继承属性和方法，通过原型链实现；\n\t- 方法共享：所有继承自原型的对象共享同一个方法的引用，减少内存使用。\n\n2. 动态弱类型语言\n不需要显式声明对象类型（可使用var关键字），并且可在运行时修改对象类型（比如将一个对象从数字改成字符串），类型转换是隐式的。\n- 动态vs静态：静态类型语言指代码在编译时检测变量类型，从而避免可能的类型错误，典型语言如C、C++、Java、C#；动态类型语言则是在运行时才检查变量的类型，意味着你可以随时改变变量的类型，代价是降低了程序的稳定性和安全性，代表性语言Python、Ruby、Javascript和PHP。\n- 弱类型vs强类型：强类型语言中，变量的类型在定义和检查时都比较严格，一旦赋予类型，不支持隐式地类型转换（自动转换），如果要转换，必须显式转换，典型例子：Java、C# 和 Rust；弱类型语言中，类型检查较为宽松，可以进行变量类型自动转换（隐式转换），比如数字和字符串可以相互转换，或者布尔值可以转换为数字，典型例子：早期Javascript和Visual Basic。\n\t- 许多现代编程语言（如 TypeScript 或 Python 3）都在向更强类型的方向发展，即使它们传统上被认为是弱类型或动态类型的。这些语言通过引入类型注解、静态类型检查工具或其他机制来增强类型安全性，同时保持了一定程度的灵活性。\n\n\n## 主要功能和应用\n了解js语言的功能和用途有助于掌握js语言的能力边界，在实际解决问题的过程中更好地选用语言、框架、技术栈，提升开发效率、降低开发难度。\n1. **web（前段）开发**\n\t- **动态网页**：JavaScript可以用来创建交互式的网页元素，如下拉菜单、弹出窗口、表单验证等。\n\t>为什么可以使用js实现交互式动态网页？\n\t>js运行在浏览器端，借助浏览器DOM操作实现对网页元素的访问和修改；通过事件处理机制实现对用户操作的监听和响应；通过AJAX异步请求等方式和服务器端进行通信，访问后端数据等。\n\t- **DOM操作**：JavaScript可以动态地修改HTML文档中的内容和样式，从而实现页面的实时更新。\n\t- **AJAX**：通过异步数据请求，JavaScript可以实现在不刷新整个页面的情况下更新部分内容，提升用户体验。\n\t- **框架和库**：如React、Angular和Vue.js等前端框架，它们基于JavaScript，用于构建复杂的Web应用程序。\n2. **服务器端开发**：\n    - **Node.js**：使开发者能够使用JavaScript进行服务器端编程，从而实现全栈JavaScript开发。\n    - **数据库操作**：通过Node.js，JavaScript可以与各种数据库（如MongoDB、MySQL）进行交互，实现数据存储和检索。\n3. **游戏开发**：\n    - **Canvas API**：用于创建2D图形和动画，常用于浏览器游戏开发。\n    - **WebGL**：用于3D图形渲染，使得复杂的游戏和可视化应用成为可能。\n4. **移动应用开发**：\n    - **React Native**、**Ionic**和**Cordova**等框架允许使用JavaScript开发跨平台的移动应用。\n5. **桌面应用程序**：\n    - **Electron**框架使得使用Web技术（HTML、CSS和JavaScript）开发跨平台的桌面应用程序成为可能。\n6. **物联网（IoT）**：\n    - **Node-RED**：一个基于Node.js的流媒体处理工具，用于构建物联网应用的数据流网络。\n7. **数据可视化**：\n    - **D3.js**等库可以帮助开发者从数据中创建复杂的可视化图表和图形。\n7. **自动化任务**：\n    - 使用Node.js，JavaScript可以编写自动化脚本来执行服务器管理、文件操作、构建过程等任务。\n9. **机器学习**：\n    - **TensorFlow.js**：允许在浏览器或Node.js环境中执行机器学习模型。\n\n# 使用\n## 开发工具\nvscode（编辑器），Nodejs（解释运行），google浏览器开发者工具（自带js引擎，调试）\n## 命名习惯\n- 变量：驼峰命名法\n- 常量：全大写，下划线间隔\n- 函数：动词在前，驼峰命名法\n- 文件名：全小写，下划线间隔\n## 教程参考\n- [JavaScript 基础 - 学习 Web 开发 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/JavaScript_basics)\n- [Javascript 简介 - 白月黑羽 (byhy.net)](https://www.byhy.net/web/js/01/)\n\n\n## 笔记\n如果你和我一样平时使用python较多，那么以下知识点你可能需要关注一下。\n\n### 变量\n\n> let和var关键字区别\n在JavaScript中，`let` 和 `var` 都用于声明变量，但它们之间有几个重要的区别：\n\n1. **作用域**:\n   - `var` 声明的变量具有函数作用域或全局作用域。这意味着在一个函数内部声明的变量在整个函数内部都是可见的，而在函数外部声明的变量则在整个脚本或全局范围内可见。\n   - `let` 声明的变量具有块级作用域。这意味着变量仅在其被声明的代码块（由 `{}` 包围的区域，如循环或条件语句）内可见。\n\n2. **变量提升 (Hoisting)**:\n   - `var` 声明的变量会被提升至作用域的顶部，即在函数或全局作用域的最开始处声明，尽管实际声明可能出现在作用域内的任何位置。\n   - `let` 声明的变量不会被提升。变量必须在使用之前声明，否则会抛出引用错误。\n\n3. **重复声明**:\n   - 使用 `var` 可以在同一作用域内多次声明同一个变量名，后一个声明会覆盖前一个。\n   - 使用 `let` 在同一作用域内不允许重复声明同一个变量名，尝试这样做会导致语法错误。\n\n4. **暂时性死区 (Temporal Dead Zone)**:\n   - `var` 声明的变量在提升之后就可以访问，尽管访问时值为 `undefined`。\n   - `let` 声明的变量在声明之前访问会抛出错误，这是因为变量存在于暂时性死区中直到其声明点。\n\n5. **全局属性**:\n   - 如果在全局作用域中使用 `var` 声明变量，该变量会自动成为全局对象（通常是 `window` 对象在浏览器环境中）的属性。\n   - 使用 `let` 在全局作用域声明的变量不会成为全局对象的属性。\n\n总结来说，`let` 提供了更严格的变量管理，增强了代码的可预测性和维护性。因此，现代JavaScript编码实践中通常推荐使用 `let` 而不是 `var`。同时，随着ES6的普及，`const` 也被广泛用于声明不可变的常量。\n\n### 字符串 引号\njs中的字符串可以用单引号、双引号、反引号，以下定义都可以：\n```js\n'字符串'\n\"字符串\"\n`字符串`\n```\n### 逻辑操作\n松散相等比较和严格相等比较\n- 严格相等比较：`1===1`返回true， `1==='1'`返回false\n- 松散相等比较：`1=='1'`返回true，在比较时会尝试转化为同种类型进行比较\n不相等同理。\n\n### 对象\n我们看到的js中通过字面量语法创建的对象和python中的字典类型在形式上有些相似，都是键值对的组合，比如：\n```js\nvar student{\n\tname: '张三'，\n\tage: 23\n}\n```\n并且js中的对象也支持通过`[]`访问对象的属性：`student['name']`，但两者在很多细节上存在一些关键区别：\n\n1. **语法差异**:\n   - 在JavaScript中，对象通常使用**字面量**语法定义，例如 `{key: value}` ，或通过构造函数 `new Object()` 创建。\n   - 在Python中，字典使用花括号 `{}` 并且键值对之间用冒号 `:` 分隔。\n\n2. **属性访问**:\n   - JavaScript中，对象的属性可以通过点符号 `.` 或方括号 `[]` 访问，例如 `obj.key` 或 `obj['key']`（适合属性名中有空格等特殊字符、属性名为变量的情况）。\n   - Python中，字典的元素只能通过方括号访问，例如 `dict['key']`。你不能使用点符号访问字典元素。\n\n3. **动态属性**:\n   - JavaScript对象允许动态添加属性，即可以在运行时向对象添加新的键值对。\n   - Python字典同样支持动态添加键值对。\n\n4. **原型继承**:\n   JavaScript对象基于原型继承，这意味着一个对象可以从另一个对象继承属性和方法。这使得JavaScript对象具有层次结构和动态性。\n   - Python字典没有这样的原型链概念，它们只包含自己的键值对，并不从其他字典继承任何东西。\n\n5. **内置方法和功能**:\n   - JavaScript对象和Python字典都有一系列内置的方法用于操作数据，但具体的方法可能不同。\n   - 例如，JavaScript中的 `hasOwnProperty`, `keys`, `values`, 和 `entries` 方法，以及Python中的 `keys()`, `values()`, `items()`, 和 `get()` 方法等。\n\n6. **用途和上下文**:\n   - JavaScript对象常用于面向对象编程（OOP），并可以作为类的实例。\n   - Python字典更常用作数据结构，用于存储和检索复杂的数据关联。\n\n7. **性能和优化**:\n   - JavaScript引擎通常会对对象的属性访问进行优化，例如V8引擎的内联缓存。\n   - Python字典的性能取决于Python解释器的实现，如CPython，它使用哈希表来实现字典，这通常提供了快速的查找时间。\n\n这些差异反映了两种语言的设计哲学和目标，JavaScript更多地被设计为一种用于Web的脚本语言，而Python则是一种通用的、高级的编程语言。\n```ad-note\ntitle: 哪些数据类型是对象？哪些不是对象？\n- 对象是基于键值对的无序集合，其中的键（也称为属性名）是字符串，而值可以是任意数据类型，包括函数（作为方法）、其他对象、原始类型（如数字、字符串、布尔值）等。\n\t- 对象是属性和方法的集合，属性用于描述对象状态，方法是封装在对象中的函数，用于执行操作或算法。两者都可以通过`.`或`[]`访问，但调用方法需要加`()`。\n\t- ==函数本身也是一种对象，因为函数拥有name和desc属性==。\n\t- \n- 非对象：\n\t- **基本数据类型（Primitive Types）**：包括 `number`、`string`、`boolean`、`undefined` 和 `null`。这些类型不是对象，它们是不可变的值。\n    \n\t- **Symbol**：ES6 引入的 Symbol 类型也不是对象，它用于创建唯一的键，常用于对象属性名。\n```\n\n```ad-note\ntitle: 如何创建对象？\n- **字面量形式创建的对象**：可以直接使用大括号 `{}` 来定义一个对象，其中可以包含各种属性和方法。\n    \n    ```js\n    const obj = { key: 'value', method: function() { /* ... */ } };\n    ```\n    \n- **通过构造函数创建的对象**：可以使用函数作为构造器，通过 `new` 关键字来创建对象实例。\n    \n    ```Javascript\n    function Person(name) {\n      this.name = name;\n    }\n    const person = new Person('Alice');\n    ```\n    \n- **使用 `Object.create()` 方法**：可以指定一个原型对象，创建的新对象将继承原型对象的属性和方法。\n \n    ```Javascript\n    const prototype = { method: function() { /* ... */ } };\n    const obj = Object.create(prototype);\n    ```\n    \n- **类（Class）**：ES6 引入了类语法，提供了一种更清晰的方式来定义对象和继承。\n    \n    ```Javascript\n    class Animal {\n      constructor(name) {\n        this.name = name;\n      }\n    }\n    const animal = new Animal('Lion');\n    ```\n- **内置对象**：JavaScript 提供了许多内置对象，如 `Array`、`Date`、`Function`、`Math`、`String` 等，它们都是对象。\n```\n\n\n### 原型和原型链\n\n原型和原型链理解js面向对象和继承机制的核心，是实现对象间属性和方法共享的基础。\n\n每个JavaScript对象，除了`null`，都有一个内部属性`Prototype`，它引用了另一个对象。这个被引用的对象就是当前对象的原型。\nJavaScript的继承机制是基于原型的，这意味着每个对象都有一个原型（除了`null`），并且可以通过原型链访问属性和方法。\n#### 继承机制\n- 原型继承\n\n当试图访问一个对象的属性或方法时，如果该对象本身不包含所查找的属性或方法，JavaScript引擎会沿着原型链向上查找，直到找到该属性或方法，或者到达原型链的末端。\n\n- 默认继承\n\n即使你不显式地设置一个对象的原型，它也会自动继承自`Object.prototype`，这是所有对象共享的基本原型，包含了如`toString`、`valueOf`等基本方法。\n\n```js\nconst obj = {};\nconsole.log(obj.toString()); // \"[object Object]\"\n```\n\n在这个例子中，`obj`对象没有显式地设置原型，但它仍然可以调用`toString`方法，这是因为`toString`方法存在于`Object.prototype`上，`obj`隐式地继承了这个方法。\n\n#### 原型链好处——属性和方法共享\n原型属性是属于该原型链的所有对象共享的，节约了内存，避免了重复定义。\n```ad-attention\n即使先创建对象，再给其原型添加属性，已经创建的对象也具有后添加的属性。\n```\n### for循环\n遍历对象时，除了可以使用`for...in...`语法，还有一种`for...of...`语法。\n两者区别：\n`for...of`循环用于遍历可迭代（Iterable）对象，如数组、字符串、Map、Set等。它按照元素的顺序访问每个元素的值，而不是键或索引。这对于需要访问集合中元素的实际值的场景非常有用。\n```js\nconst fruits = ['apple', 'banana', 'cherry']; \nfor (const fruit of fruits) { \n\tconsole.log(fruit); \n\t}\n```\n`for...in`循环则用于枚举一个对象的所有可枚举属性的键。这在遍历对象的属性时非常有用，但它返回的是属性名，而不是属性值。对于数组来说，它会遍历数组的索引，包括稀疏数组中的未定义项以及继承的属性。\n```js\nconst person = { name: 'John', age: 30, city: 'New York' }; \nfor (const prop in person) { \n\tif (person.hasOwnProperty(prop)) { \n\tconsole.log(`${prop}: ${person[prop]}`); \n\t} \n}\n```\n\n### 剩余参数\n剩余参数语法可以将一个不定数量的参数表示为一个数组，用`...`表示。相当于python中的可变参数列表`*args`\n```js\nvar fruitInfo = {\n\t'apple' : 4,\n\t'banana': 10,\n\t'peach': 6,\n\t'watermelon': 3,\n}\n\nfunction printFruitInfo(...fruits){\n\tfor(let fruit of fruits){\n\t\tconsole.log(`fruit: ${fruit}, num: ${fruitInfo[fruit]}`);\n\t}\n}\n//调用函数\nprintFruitInfo('apple', 'banana', 'peach')\n```\n上述代码使用python表示时：\n```python\nfruit_info = { 'apple': 4, 'banana': 10, 'peach': 6, 'watermelon': 3, } \ndef print_fruit_info(*fruits): \n\tfor fruit in fruits: \n\t\tprint(f\"fruit: {fruit}, num: {fruit_info[fruit]}\") \n# 调用函数 \nprint_fruit_info('apple', 'banana', 'peach')\n```\n\n### 单线程异步编程\njs最初设计被用于进行web开发，通过事件处理机制来对用户事件进行监听和响应，js引擎使用异步架构。\n在js中，异步（Asynchronous）编程是一种允许你的程序在等待某些耗时操作（如网络请求、文件读写、定时器、数据库查询等）完成的同时，继续执行其他任务的编程模式。异步编程是JavaScript处理并发和I/O密集型操作的关键特性，它使得Web应用程序能够保持响应性和性能。\n\n与之相对的是同步（Synchronous）编程，其中程序会按顺序执行每一行代码，如果遇到耗时操作，程序会停下来等待这个操作完成，然后再继续执行下一行代码。这在单线程环境中（如JavaScript在浏览器中的执行环境）会导致阻塞，降低用户体验，尤其是在处理长时间运行的任务时。\n\nJavaScript使用事件循环（Event Loop）机制来支持异步编程。事件循环检查是否有待处理的事件或回调函数，如果有，就将它们加入到执行队列中，然后在当前任务完成后按顺序执行这些任务。这意味着，即使你的代码中包含了一些耗时操作，js引擎也不会停止执行其他代码，而是将这些耗时操作委托给操作系统或者其他线程去处理，一旦这些操作完成，再通过回调函数、Promise、async/await等方式通知主执行线程。\n\n需要注意的是，js从设计之初就是一个单线程语言，即使看上去回调函数和主程序在并发执行，但其实都运行在一个主线程中。这种单线程异步编程方式的优点在于：\n- 不需要考虑线程同步和资源竞争；\n-  从源头上避免了线程间的切换，降低线程自身开销；\n\n#### 常见的异步编程方式\n\n1. **回调函数（Callback）**：将一个函数作为参数传递到另一个函数中，并在另一个函数中调用，这个函数就是回调函数（两个条件，外部调用，内部定义）。回调函数需要预先定义好，在发起异步操作时，同时提供一个回调函数，当异步操作完成时调用这个函数。\n```js\n//setTimeout模仿异步操作，两秒后调用回调函数callback\nfunction fetchData(callback) { \n\tsetTimeout(() => { \n\t\tconst data = 'Hello from the server!'; \n\t\tcallback(data); \n\t\t}, 2000); \n\t}\nfetchData((data) => { \n\tconsole.log(data); \n\t});\n```\n回调函数缺点：当需要依次执行多个异步操作时，容易陷入回调地狱。\n\n2. **Promise**：一种更为现代的处理异步操作的方法，允许以**链式**调用的方式处理异步操作的结果，通过链式调用避免层层嵌套，提升可读性。js中的fetch API就是一个很好的例子。\n```js\nfetch(\"https://jsonplaceholder.typicode.com/posts/1\")\n\t.then((response)=>response.json())\n\t.then((json)=>{\n\t\tconsole.log(json);\n\t})\n\t.catch((error)=>{\n\t\tconsole.error(error);\n\t})\n\tfinally(()=>{\n\t\tstopLoadingAnimation();              //类似try-catch-finally结构\n\t});\n\n```\nPromise是ES6中引入的用于简化异步编程的构造。Promise对象代表一个最终可能完成或失败的异步操作，它有三种状态：pending（等待中）、fulfilled（已完成）和rejected（已拒绝）。\n从字面理解`Promise`——承诺会在未来某个时刻返回数据，异步函数可以理解为返回值为Promise对象的函数。\n\n3. **Async/Await**：基于Promise的语法糖（不改变实际功能，但提升程序可读性），使异步代码看起来更像同步代码，提高了代码的可读性和可维护性。\n```js\nasync function f(){  //使用async关键字将函数标记为异步函数\n\tconst response = await fetch(\"http://\") //使用await代替then \n\tconst json = await response.json();\n\tconsole.log(json);\n}  \nf(); \n```\n异步编程虽然增加了代码的复杂性，但它是构建高性能、高响应性的现代Web应用所必需的。\n","source":"_posts/python转javascript学习笔记（一）.md","raw":"---\ntitle: python转javascript学习笔记（一）\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags: 'javascript, python, 单线程, 异步'\ndate: 2024-06-18 12:39:30\npassword:\nsummary:\ncategories:\n---\n\n# JavaScript简介\n## 语言规范\nJavaScript语言遵循ECMAScript规范（简称ES），ECMA即欧洲计算机协会，该规范定义了JavaScript（以下统一使用js缩写）语言的核心特性，确保不同环境下的js实现（比如浏览器内置js引擎、Nodejs、其他服务器端js运行时等）的一致性和互操作性。ES6或ES2015（2015年6月发行）是该规范发行以来的一个重要里程碑，也是主流浏览器基本支持的版本。\n\n## 特性和应用场景\n1. 基于原型的面向对象语言，在动态修改和扩展对象上更加灵活（弱化了结构和可维护性）。\n- 与传统的面向对象编程范式（Java/C++/C#等）的主要区别：\n\t- 创建机制：创建对象时，无需定义类模板，通过从对已有对象的克隆或引用创建；\n\t- 继承机制：直接从原型对象继承属性和方法，通过原型链实现；\n\t- 方法共享：所有继承自原型的对象共享同一个方法的引用，减少内存使用。\n\n2. 动态弱类型语言\n不需要显式声明对象类型（可使用var关键字），并且可在运行时修改对象类型（比如将一个对象从数字改成字符串），类型转换是隐式的。\n- 动态vs静态：静态类型语言指代码在编译时检测变量类型，从而避免可能的类型错误，典型语言如C、C++、Java、C#；动态类型语言则是在运行时才检查变量的类型，意味着你可以随时改变变量的类型，代价是降低了程序的稳定性和安全性，代表性语言Python、Ruby、Javascript和PHP。\n- 弱类型vs强类型：强类型语言中，变量的类型在定义和检查时都比较严格，一旦赋予类型，不支持隐式地类型转换（自动转换），如果要转换，必须显式转换，典型例子：Java、C# 和 Rust；弱类型语言中，类型检查较为宽松，可以进行变量类型自动转换（隐式转换），比如数字和字符串可以相互转换，或者布尔值可以转换为数字，典型例子：早期Javascript和Visual Basic。\n\t- 许多现代编程语言（如 TypeScript 或 Python 3）都在向更强类型的方向发展，即使它们传统上被认为是弱类型或动态类型的。这些语言通过引入类型注解、静态类型检查工具或其他机制来增强类型安全性，同时保持了一定程度的灵活性。\n\n\n## 主要功能和应用\n了解js语言的功能和用途有助于掌握js语言的能力边界，在实际解决问题的过程中更好地选用语言、框架、技术栈，提升开发效率、降低开发难度。\n1. **web（前段）开发**\n\t- **动态网页**：JavaScript可以用来创建交互式的网页元素，如下拉菜单、弹出窗口、表单验证等。\n\t>为什么可以使用js实现交互式动态网页？\n\t>js运行在浏览器端，借助浏览器DOM操作实现对网页元素的访问和修改；通过事件处理机制实现对用户操作的监听和响应；通过AJAX异步请求等方式和服务器端进行通信，访问后端数据等。\n\t- **DOM操作**：JavaScript可以动态地修改HTML文档中的内容和样式，从而实现页面的实时更新。\n\t- **AJAX**：通过异步数据请求，JavaScript可以实现在不刷新整个页面的情况下更新部分内容，提升用户体验。\n\t- **框架和库**：如React、Angular和Vue.js等前端框架，它们基于JavaScript，用于构建复杂的Web应用程序。\n2. **服务器端开发**：\n    - **Node.js**：使开发者能够使用JavaScript进行服务器端编程，从而实现全栈JavaScript开发。\n    - **数据库操作**：通过Node.js，JavaScript可以与各种数据库（如MongoDB、MySQL）进行交互，实现数据存储和检索。\n3. **游戏开发**：\n    - **Canvas API**：用于创建2D图形和动画，常用于浏览器游戏开发。\n    - **WebGL**：用于3D图形渲染，使得复杂的游戏和可视化应用成为可能。\n4. **移动应用开发**：\n    - **React Native**、**Ionic**和**Cordova**等框架允许使用JavaScript开发跨平台的移动应用。\n5. **桌面应用程序**：\n    - **Electron**框架使得使用Web技术（HTML、CSS和JavaScript）开发跨平台的桌面应用程序成为可能。\n6. **物联网（IoT）**：\n    - **Node-RED**：一个基于Node.js的流媒体处理工具，用于构建物联网应用的数据流网络。\n7. **数据可视化**：\n    - **D3.js**等库可以帮助开发者从数据中创建复杂的可视化图表和图形。\n7. **自动化任务**：\n    - 使用Node.js，JavaScript可以编写自动化脚本来执行服务器管理、文件操作、构建过程等任务。\n9. **机器学习**：\n    - **TensorFlow.js**：允许在浏览器或Node.js环境中执行机器学习模型。\n\n# 使用\n## 开发工具\nvscode（编辑器），Nodejs（解释运行），google浏览器开发者工具（自带js引擎，调试）\n## 命名习惯\n- 变量：驼峰命名法\n- 常量：全大写，下划线间隔\n- 函数：动词在前，驼峰命名法\n- 文件名：全小写，下划线间隔\n## 教程参考\n- [JavaScript 基础 - 学习 Web 开发 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/JavaScript_basics)\n- [Javascript 简介 - 白月黑羽 (byhy.net)](https://www.byhy.net/web/js/01/)\n\n\n## 笔记\n如果你和我一样平时使用python较多，那么以下知识点你可能需要关注一下。\n\n### 变量\n\n> let和var关键字区别\n在JavaScript中，`let` 和 `var` 都用于声明变量，但它们之间有几个重要的区别：\n\n1. **作用域**:\n   - `var` 声明的变量具有函数作用域或全局作用域。这意味着在一个函数内部声明的变量在整个函数内部都是可见的，而在函数外部声明的变量则在整个脚本或全局范围内可见。\n   - `let` 声明的变量具有块级作用域。这意味着变量仅在其被声明的代码块（由 `{}` 包围的区域，如循环或条件语句）内可见。\n\n2. **变量提升 (Hoisting)**:\n   - `var` 声明的变量会被提升至作用域的顶部，即在函数或全局作用域的最开始处声明，尽管实际声明可能出现在作用域内的任何位置。\n   - `let` 声明的变量不会被提升。变量必须在使用之前声明，否则会抛出引用错误。\n\n3. **重复声明**:\n   - 使用 `var` 可以在同一作用域内多次声明同一个变量名，后一个声明会覆盖前一个。\n   - 使用 `let` 在同一作用域内不允许重复声明同一个变量名，尝试这样做会导致语法错误。\n\n4. **暂时性死区 (Temporal Dead Zone)**:\n   - `var` 声明的变量在提升之后就可以访问，尽管访问时值为 `undefined`。\n   - `let` 声明的变量在声明之前访问会抛出错误，这是因为变量存在于暂时性死区中直到其声明点。\n\n5. **全局属性**:\n   - 如果在全局作用域中使用 `var` 声明变量，该变量会自动成为全局对象（通常是 `window` 对象在浏览器环境中）的属性。\n   - 使用 `let` 在全局作用域声明的变量不会成为全局对象的属性。\n\n总结来说，`let` 提供了更严格的变量管理，增强了代码的可预测性和维护性。因此，现代JavaScript编码实践中通常推荐使用 `let` 而不是 `var`。同时，随着ES6的普及，`const` 也被广泛用于声明不可变的常量。\n\n### 字符串 引号\njs中的字符串可以用单引号、双引号、反引号，以下定义都可以：\n```js\n'字符串'\n\"字符串\"\n`字符串`\n```\n### 逻辑操作\n松散相等比较和严格相等比较\n- 严格相等比较：`1===1`返回true， `1==='1'`返回false\n- 松散相等比较：`1=='1'`返回true，在比较时会尝试转化为同种类型进行比较\n不相等同理。\n\n### 对象\n我们看到的js中通过字面量语法创建的对象和python中的字典类型在形式上有些相似，都是键值对的组合，比如：\n```js\nvar student{\n\tname: '张三'，\n\tage: 23\n}\n```\n并且js中的对象也支持通过`[]`访问对象的属性：`student['name']`，但两者在很多细节上存在一些关键区别：\n\n1. **语法差异**:\n   - 在JavaScript中，对象通常使用**字面量**语法定义，例如 `{key: value}` ，或通过构造函数 `new Object()` 创建。\n   - 在Python中，字典使用花括号 `{}` 并且键值对之间用冒号 `:` 分隔。\n\n2. **属性访问**:\n   - JavaScript中，对象的属性可以通过点符号 `.` 或方括号 `[]` 访问，例如 `obj.key` 或 `obj['key']`（适合属性名中有空格等特殊字符、属性名为变量的情况）。\n   - Python中，字典的元素只能通过方括号访问，例如 `dict['key']`。你不能使用点符号访问字典元素。\n\n3. **动态属性**:\n   - JavaScript对象允许动态添加属性，即可以在运行时向对象添加新的键值对。\n   - Python字典同样支持动态添加键值对。\n\n4. **原型继承**:\n   JavaScript对象基于原型继承，这意味着一个对象可以从另一个对象继承属性和方法。这使得JavaScript对象具有层次结构和动态性。\n   - Python字典没有这样的原型链概念，它们只包含自己的键值对，并不从其他字典继承任何东西。\n\n5. **内置方法和功能**:\n   - JavaScript对象和Python字典都有一系列内置的方法用于操作数据，但具体的方法可能不同。\n   - 例如，JavaScript中的 `hasOwnProperty`, `keys`, `values`, 和 `entries` 方法，以及Python中的 `keys()`, `values()`, `items()`, 和 `get()` 方法等。\n\n6. **用途和上下文**:\n   - JavaScript对象常用于面向对象编程（OOP），并可以作为类的实例。\n   - Python字典更常用作数据结构，用于存储和检索复杂的数据关联。\n\n7. **性能和优化**:\n   - JavaScript引擎通常会对对象的属性访问进行优化，例如V8引擎的内联缓存。\n   - Python字典的性能取决于Python解释器的实现，如CPython，它使用哈希表来实现字典，这通常提供了快速的查找时间。\n\n这些差异反映了两种语言的设计哲学和目标，JavaScript更多地被设计为一种用于Web的脚本语言，而Python则是一种通用的、高级的编程语言。\n```ad-note\ntitle: 哪些数据类型是对象？哪些不是对象？\n- 对象是基于键值对的无序集合，其中的键（也称为属性名）是字符串，而值可以是任意数据类型，包括函数（作为方法）、其他对象、原始类型（如数字、字符串、布尔值）等。\n\t- 对象是属性和方法的集合，属性用于描述对象状态，方法是封装在对象中的函数，用于执行操作或算法。两者都可以通过`.`或`[]`访问，但调用方法需要加`()`。\n\t- ==函数本身也是一种对象，因为函数拥有name和desc属性==。\n\t- \n- 非对象：\n\t- **基本数据类型（Primitive Types）**：包括 `number`、`string`、`boolean`、`undefined` 和 `null`。这些类型不是对象，它们是不可变的值。\n    \n\t- **Symbol**：ES6 引入的 Symbol 类型也不是对象，它用于创建唯一的键，常用于对象属性名。\n```\n\n```ad-note\ntitle: 如何创建对象？\n- **字面量形式创建的对象**：可以直接使用大括号 `{}` 来定义一个对象，其中可以包含各种属性和方法。\n    \n    ```js\n    const obj = { key: 'value', method: function() { /* ... */ } };\n    ```\n    \n- **通过构造函数创建的对象**：可以使用函数作为构造器，通过 `new` 关键字来创建对象实例。\n    \n    ```Javascript\n    function Person(name) {\n      this.name = name;\n    }\n    const person = new Person('Alice');\n    ```\n    \n- **使用 `Object.create()` 方法**：可以指定一个原型对象，创建的新对象将继承原型对象的属性和方法。\n \n    ```Javascript\n    const prototype = { method: function() { /* ... */ } };\n    const obj = Object.create(prototype);\n    ```\n    \n- **类（Class）**：ES6 引入了类语法，提供了一种更清晰的方式来定义对象和继承。\n    \n    ```Javascript\n    class Animal {\n      constructor(name) {\n        this.name = name;\n      }\n    }\n    const animal = new Animal('Lion');\n    ```\n- **内置对象**：JavaScript 提供了许多内置对象，如 `Array`、`Date`、`Function`、`Math`、`String` 等，它们都是对象。\n```\n\n\n### 原型和原型链\n\n原型和原型链理解js面向对象和继承机制的核心，是实现对象间属性和方法共享的基础。\n\n每个JavaScript对象，除了`null`，都有一个内部属性`Prototype`，它引用了另一个对象。这个被引用的对象就是当前对象的原型。\nJavaScript的继承机制是基于原型的，这意味着每个对象都有一个原型（除了`null`），并且可以通过原型链访问属性和方法。\n#### 继承机制\n- 原型继承\n\n当试图访问一个对象的属性或方法时，如果该对象本身不包含所查找的属性或方法，JavaScript引擎会沿着原型链向上查找，直到找到该属性或方法，或者到达原型链的末端。\n\n- 默认继承\n\n即使你不显式地设置一个对象的原型，它也会自动继承自`Object.prototype`，这是所有对象共享的基本原型，包含了如`toString`、`valueOf`等基本方法。\n\n```js\nconst obj = {};\nconsole.log(obj.toString()); // \"[object Object]\"\n```\n\n在这个例子中，`obj`对象没有显式地设置原型，但它仍然可以调用`toString`方法，这是因为`toString`方法存在于`Object.prototype`上，`obj`隐式地继承了这个方法。\n\n#### 原型链好处——属性和方法共享\n原型属性是属于该原型链的所有对象共享的，节约了内存，避免了重复定义。\n```ad-attention\n即使先创建对象，再给其原型添加属性，已经创建的对象也具有后添加的属性。\n```\n### for循环\n遍历对象时，除了可以使用`for...in...`语法，还有一种`for...of...`语法。\n两者区别：\n`for...of`循环用于遍历可迭代（Iterable）对象，如数组、字符串、Map、Set等。它按照元素的顺序访问每个元素的值，而不是键或索引。这对于需要访问集合中元素的实际值的场景非常有用。\n```js\nconst fruits = ['apple', 'banana', 'cherry']; \nfor (const fruit of fruits) { \n\tconsole.log(fruit); \n\t}\n```\n`for...in`循环则用于枚举一个对象的所有可枚举属性的键。这在遍历对象的属性时非常有用，但它返回的是属性名，而不是属性值。对于数组来说，它会遍历数组的索引，包括稀疏数组中的未定义项以及继承的属性。\n```js\nconst person = { name: 'John', age: 30, city: 'New York' }; \nfor (const prop in person) { \n\tif (person.hasOwnProperty(prop)) { \n\tconsole.log(`${prop}: ${person[prop]}`); \n\t} \n}\n```\n\n### 剩余参数\n剩余参数语法可以将一个不定数量的参数表示为一个数组，用`...`表示。相当于python中的可变参数列表`*args`\n```js\nvar fruitInfo = {\n\t'apple' : 4,\n\t'banana': 10,\n\t'peach': 6,\n\t'watermelon': 3,\n}\n\nfunction printFruitInfo(...fruits){\n\tfor(let fruit of fruits){\n\t\tconsole.log(`fruit: ${fruit}, num: ${fruitInfo[fruit]}`);\n\t}\n}\n//调用函数\nprintFruitInfo('apple', 'banana', 'peach')\n```\n上述代码使用python表示时：\n```python\nfruit_info = { 'apple': 4, 'banana': 10, 'peach': 6, 'watermelon': 3, } \ndef print_fruit_info(*fruits): \n\tfor fruit in fruits: \n\t\tprint(f\"fruit: {fruit}, num: {fruit_info[fruit]}\") \n# 调用函数 \nprint_fruit_info('apple', 'banana', 'peach')\n```\n\n### 单线程异步编程\njs最初设计被用于进行web开发，通过事件处理机制来对用户事件进行监听和响应，js引擎使用异步架构。\n在js中，异步（Asynchronous）编程是一种允许你的程序在等待某些耗时操作（如网络请求、文件读写、定时器、数据库查询等）完成的同时，继续执行其他任务的编程模式。异步编程是JavaScript处理并发和I/O密集型操作的关键特性，它使得Web应用程序能够保持响应性和性能。\n\n与之相对的是同步（Synchronous）编程，其中程序会按顺序执行每一行代码，如果遇到耗时操作，程序会停下来等待这个操作完成，然后再继续执行下一行代码。这在单线程环境中（如JavaScript在浏览器中的执行环境）会导致阻塞，降低用户体验，尤其是在处理长时间运行的任务时。\n\nJavaScript使用事件循环（Event Loop）机制来支持异步编程。事件循环检查是否有待处理的事件或回调函数，如果有，就将它们加入到执行队列中，然后在当前任务完成后按顺序执行这些任务。这意味着，即使你的代码中包含了一些耗时操作，js引擎也不会停止执行其他代码，而是将这些耗时操作委托给操作系统或者其他线程去处理，一旦这些操作完成，再通过回调函数、Promise、async/await等方式通知主执行线程。\n\n需要注意的是，js从设计之初就是一个单线程语言，即使看上去回调函数和主程序在并发执行，但其实都运行在一个主线程中。这种单线程异步编程方式的优点在于：\n- 不需要考虑线程同步和资源竞争；\n-  从源头上避免了线程间的切换，降低线程自身开销；\n\n#### 常见的异步编程方式\n\n1. **回调函数（Callback）**：将一个函数作为参数传递到另一个函数中，并在另一个函数中调用，这个函数就是回调函数（两个条件，外部调用，内部定义）。回调函数需要预先定义好，在发起异步操作时，同时提供一个回调函数，当异步操作完成时调用这个函数。\n```js\n//setTimeout模仿异步操作，两秒后调用回调函数callback\nfunction fetchData(callback) { \n\tsetTimeout(() => { \n\t\tconst data = 'Hello from the server!'; \n\t\tcallback(data); \n\t\t}, 2000); \n\t}\nfetchData((data) => { \n\tconsole.log(data); \n\t});\n```\n回调函数缺点：当需要依次执行多个异步操作时，容易陷入回调地狱。\n\n2. **Promise**：一种更为现代的处理异步操作的方法，允许以**链式**调用的方式处理异步操作的结果，通过链式调用避免层层嵌套，提升可读性。js中的fetch API就是一个很好的例子。\n```js\nfetch(\"https://jsonplaceholder.typicode.com/posts/1\")\n\t.then((response)=>response.json())\n\t.then((json)=>{\n\t\tconsole.log(json);\n\t})\n\t.catch((error)=>{\n\t\tconsole.error(error);\n\t})\n\tfinally(()=>{\n\t\tstopLoadingAnimation();              //类似try-catch-finally结构\n\t});\n\n```\nPromise是ES6中引入的用于简化异步编程的构造。Promise对象代表一个最终可能完成或失败的异步操作，它有三种状态：pending（等待中）、fulfilled（已完成）和rejected（已拒绝）。\n从字面理解`Promise`——承诺会在未来某个时刻返回数据，异步函数可以理解为返回值为Promise对象的函数。\n\n3. **Async/Await**：基于Promise的语法糖（不改变实际功能，但提升程序可读性），使异步代码看起来更像同步代码，提高了代码的可读性和可维护性。\n```js\nasync function f(){  //使用async关键字将函数标记为异步函数\n\tconst response = await fetch(\"http://\") //使用await代替then \n\tconst json = await response.json();\n\tconsole.log(json);\n}  \nf(); \n```\n异步编程虽然增加了代码的复杂性，但它是构建高性能、高响应性的现代Web应用所必需的。\n","slug":"python转javascript学习笔记（一）","published":1,"updated":"2024-06-18T04:55:58.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly2zhjn3000bxdqredmp0f5x","content":"<h1 id=\"JavaScript简介\"><a href=\"#JavaScript简介\" class=\"headerlink\" title=\"JavaScript简介\"></a>JavaScript简介</h1><h2 id=\"语言规范\"><a href=\"#语言规范\" class=\"headerlink\" title=\"语言规范\"></a>语言规范</h2><p>JavaScript语言遵循ECMAScript规范（简称ES），ECMA即欧洲计算机协会，该规范定义了JavaScript（以下统一使用js缩写）语言的核心特性，确保不同环境下的js实现（比如浏览器内置js引擎、Nodejs、其他服务器端js运行时等）的一致性和互操作性。ES6或ES2015（2015年6月发行）是该规范发行以来的一个重要里程碑，也是主流浏览器基本支持的版本。</p>\n<h2 id=\"特性和应用场景\"><a href=\"#特性和应用场景\" class=\"headerlink\" title=\"特性和应用场景\"></a>特性和应用场景</h2><ol>\n<li>基于原型的面向对象语言，在动态修改和扩展对象上更加灵活（弱化了结构和可维护性）。</li>\n</ol>\n<ul>\n<li>与传统的面向对象编程范式（Java&#x2F;C++&#x2F;C#等）的主要区别：<ul>\n<li>创建机制：创建对象时，无需定义类模板，通过从对已有对象的克隆或引用创建；</li>\n<li>继承机制：直接从原型对象继承属性和方法，通过原型链实现；</li>\n<li>方法共享：所有继承自原型的对象共享同一个方法的引用，减少内存使用。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>动态弱类型语言<br>不需要显式声明对象类型（可使用var关键字），并且可在运行时修改对象类型（比如将一个对象从数字改成字符串），类型转换是隐式的。</li>\n</ol>\n<ul>\n<li>动态vs静态：静态类型语言指代码在编译时检测变量类型，从而避免可能的类型错误，典型语言如C、C++、Java、C#；动态类型语言则是在运行时才检查变量的类型，意味着你可以随时改变变量的类型，代价是降低了程序的稳定性和安全性，代表性语言Python、Ruby、Javascript和PHP。</li>\n<li>弱类型vs强类型：强类型语言中，变量的类型在定义和检查时都比较严格，一旦赋予类型，不支持隐式地类型转换（自动转换），如果要转换，必须显式转换，典型例子：Java、C# 和 Rust；弱类型语言中，类型检查较为宽松，可以进行变量类型自动转换（隐式转换），比如数字和字符串可以相互转换，或者布尔值可以转换为数字，典型例子：早期Javascript和Visual Basic。<ul>\n<li>许多现代编程语言（如 TypeScript 或 Python 3）都在向更强类型的方向发展，即使它们传统上被认为是弱类型或动态类型的。这些语言通过引入类型注解、静态类型检查工具或其他机制来增强类型安全性，同时保持了一定程度的灵活性。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"主要功能和应用\"><a href=\"#主要功能和应用\" class=\"headerlink\" title=\"主要功能和应用\"></a>主要功能和应用</h2><p>了解js语言的功能和用途有助于掌握js语言的能力边界，在实际解决问题的过程中更好地选用语言、框架、技术栈，提升开发效率、降低开发难度。</p>\n<ol>\n<li><strong>web（前段）开发</strong><ul>\n<li><strong>动态网页</strong>：JavaScript可以用来创建交互式的网页元素，如下拉菜单、弹出窗口、表单验证等。<blockquote>\n<p>为什么可以使用js实现交互式动态网页？<br>js运行在浏览器端，借助浏览器DOM操作实现对网页元素的访问和修改；通过事件处理机制实现对用户操作的监听和响应；通过AJAX异步请求等方式和服务器端进行通信，访问后端数据等。</p>\n</blockquote>\n</li>\n<li><strong>DOM操作</strong>：JavaScript可以动态地修改HTML文档中的内容和样式，从而实现页面的实时更新。</li>\n<li><strong>AJAX</strong>：通过异步数据请求，JavaScript可以实现在不刷新整个页面的情况下更新部分内容，提升用户体验。</li>\n<li><strong>框架和库</strong>：如React、Angular和Vue.js等前端框架，它们基于JavaScript，用于构建复杂的Web应用程序。</li>\n</ul>\n</li>\n<li><strong>服务器端开发</strong>：<ul>\n<li><strong>Node.js</strong>：使开发者能够使用JavaScript进行服务器端编程，从而实现全栈JavaScript开发。</li>\n<li><strong>数据库操作</strong>：通过Node.js，JavaScript可以与各种数据库（如MongoDB、MySQL）进行交互，实现数据存储和检索。</li>\n</ul>\n</li>\n<li><strong>游戏开发</strong>：<ul>\n<li><strong>Canvas API</strong>：用于创建2D图形和动画，常用于浏览器游戏开发。</li>\n<li><strong>WebGL</strong>：用于3D图形渲染，使得复杂的游戏和可视化应用成为可能。</li>\n</ul>\n</li>\n<li><strong>移动应用开发</strong>：<ul>\n<li><strong>React Native</strong>、<strong>Ionic</strong>和<strong>Cordova</strong>等框架允许使用JavaScript开发跨平台的移动应用。</li>\n</ul>\n</li>\n<li><strong>桌面应用程序</strong>：<ul>\n<li><strong>Electron</strong>框架使得使用Web技术（HTML、CSS和JavaScript）开发跨平台的桌面应用程序成为可能。</li>\n</ul>\n</li>\n<li><strong>物联网（IoT）</strong>：<ul>\n<li><strong>Node-RED</strong>：一个基于Node.js的流媒体处理工具，用于构建物联网应用的数据流网络。</li>\n</ul>\n</li>\n<li><strong>数据可视化</strong>：<ul>\n<li><strong>D3.js</strong>等库可以帮助开发者从数据中创建复杂的可视化图表和图形。</li>\n</ul>\n</li>\n<li><strong>自动化任务</strong>：<ul>\n<li>使用Node.js，JavaScript可以编写自动化脚本来执行服务器管理、文件操作、构建过程等任务。</li>\n</ul>\n</li>\n<li><strong>机器学习</strong>：<ul>\n<li><strong>TensorFlow.js</strong>：允许在浏览器或Node.js环境中执行机器学习模型。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h2><p>vscode（编辑器），Nodejs（解释运行），google浏览器开发者工具（自带js引擎，调试）</p>\n<h2 id=\"命名习惯\"><a href=\"#命名习惯\" class=\"headerlink\" title=\"命名习惯\"></a>命名习惯</h2><ul>\n<li>变量：驼峰命名法</li>\n<li>常量：全大写，下划线间隔</li>\n<li>函数：动词在前，驼峰命名法</li>\n<li>文件名：全小写，下划线间隔</li>\n</ul>\n<h2 id=\"教程参考\"><a href=\"#教程参考\" class=\"headerlink\" title=\"教程参考\"></a>教程参考</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/JavaScript_basics\">JavaScript 基础 - 学习 Web 开发 | MDN (mozilla.org)</a></li>\n<li><a href=\"https://www.byhy.net/web/js/01/\">Javascript 简介 - 白月黑羽 (byhy.net)</a></li>\n</ul>\n<h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><p>如果你和我一样平时使用python较多，那么以下知识点你可能需要关注一下。</p>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><blockquote>\n<p>let和var关键字区别<br>在JavaScript中，<code>let</code> 和 <code>var</code> 都用于声明变量，但它们之间有几个重要的区别：</p>\n</blockquote>\n<ol>\n<li><p><strong>作用域</strong>:</p>\n<ul>\n<li><code>var</code> 声明的变量具有函数作用域或全局作用域。这意味着在一个函数内部声明的变量在整个函数内部都是可见的，而在函数外部声明的变量则在整个脚本或全局范围内可见。</li>\n<li><code>let</code> 声明的变量具有块级作用域。这意味着变量仅在其被声明的代码块（由 <code>&#123;&#125;</code> 包围的区域，如循环或条件语句）内可见。</li>\n</ul>\n</li>\n<li><p><strong>变量提升 (Hoisting)</strong>:</p>\n<ul>\n<li><code>var</code> 声明的变量会被提升至作用域的顶部，即在函数或全局作用域的最开始处声明，尽管实际声明可能出现在作用域内的任何位置。</li>\n<li><code>let</code> 声明的变量不会被提升。变量必须在使用之前声明，否则会抛出引用错误。</li>\n</ul>\n</li>\n<li><p><strong>重复声明</strong>:</p>\n<ul>\n<li>使用 <code>var</code> 可以在同一作用域内多次声明同一个变量名，后一个声明会覆盖前一个。</li>\n<li>使用 <code>let</code> 在同一作用域内不允许重复声明同一个变量名，尝试这样做会导致语法错误。</li>\n</ul>\n</li>\n<li><p><strong>暂时性死区 (Temporal Dead Zone)</strong>:</p>\n<ul>\n<li><code>var</code> 声明的变量在提升之后就可以访问，尽管访问时值为 <code>undefined</code>。</li>\n<li><code>let</code> 声明的变量在声明之前访问会抛出错误，这是因为变量存在于暂时性死区中直到其声明点。</li>\n</ul>\n</li>\n<li><p><strong>全局属性</strong>:</p>\n<ul>\n<li>如果在全局作用域中使用 <code>var</code> 声明变量，该变量会自动成为全局对象（通常是 <code>window</code> 对象在浏览器环境中）的属性。</li>\n<li>使用 <code>let</code> 在全局作用域声明的变量不会成为全局对象的属性。</li>\n</ul>\n</li>\n</ol>\n<p>总结来说，<code>let</code> 提供了更严格的变量管理，增强了代码的可预测性和维护性。因此，现代JavaScript编码实践中通常推荐使用 <code>let</code> 而不是 <code>var</code>。同时，随着ES6的普及，<code>const</code> 也被广泛用于声明不可变的常量。</p>\n<h3 id=\"字符串-引号\"><a href=\"#字符串-引号\" class=\"headerlink\" title=\"字符串 引号\"></a>字符串 引号</h3><p>js中的字符串可以用单引号、双引号、反引号，以下定义都可以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-string\">&#x27;字符串&#x27;</span><br><span class=\"hljs-string\">&quot;字符串&quot;</span><br><span class=\"hljs-string\">`字符串`</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"逻辑操作\"><a href=\"#逻辑操作\" class=\"headerlink\" title=\"逻辑操作\"></a>逻辑操作</h3><p>松散相等比较和严格相等比较</p>\n<ul>\n<li>严格相等比较：<code>1===1</code>返回true， <code>1===&#39;1&#39;</code>返回false</li>\n<li>松散相等比较：<code>1==&#39;1&#39;</code>返回true，在比较时会尝试转化为同种类型进行比较<br>不相等同理。</li>\n</ul>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>我们看到的js中通过字面量语法创建的对象和python中的字典类型在形式上有些相似，都是键值对的组合，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> student&#123;<br>\t<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;张三&#x27;</span>，<br>\t<span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">23</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>并且js中的对象也支持通过<code>[]</code>访问对象的属性：<code>student[&#39;name&#39;]</code>，但两者在很多细节上存在一些关键区别：</p>\n<ol>\n<li><p><strong>语法差异</strong>:</p>\n<ul>\n<li>在JavaScript中，对象通常使用<strong>字面量</strong>语法定义，例如 <code>&#123;key: value&#125;</code> ，或通过构造函数 <code>new Object()</code> 创建。</li>\n<li>在Python中，字典使用花括号 <code>&#123;&#125;</code> 并且键值对之间用冒号 <code>:</code> 分隔。</li>\n</ul>\n</li>\n<li><p><strong>属性访问</strong>:</p>\n<ul>\n<li>JavaScript中，对象的属性可以通过点符号 <code>.</code> 或方括号 <code>[]</code> 访问，例如 <code>obj.key</code> 或 <code>obj[&#39;key&#39;]</code>（适合属性名中有空格等特殊字符、属性名为变量的情况）。</li>\n<li>Python中，字典的元素只能通过方括号访问，例如 <code>dict[&#39;key&#39;]</code>。你不能使用点符号访问字典元素。</li>\n</ul>\n</li>\n<li><p><strong>动态属性</strong>:</p>\n<ul>\n<li>JavaScript对象允许动态添加属性，即可以在运行时向对象添加新的键值对。</li>\n<li>Python字典同样支持动态添加键值对。</li>\n</ul>\n</li>\n<li><p><strong>原型继承</strong>:<br>JavaScript对象基于原型继承，这意味着一个对象可以从另一个对象继承属性和方法。这使得JavaScript对象具有层次结构和动态性。</p>\n<ul>\n<li>Python字典没有这样的原型链概念，它们只包含自己的键值对，并不从其他字典继承任何东西。</li>\n</ul>\n</li>\n<li><p><strong>内置方法和功能</strong>:</p>\n<ul>\n<li>JavaScript对象和Python字典都有一系列内置的方法用于操作数据，但具体的方法可能不同。</li>\n<li>例如，JavaScript中的 <code>hasOwnProperty</code>, <code>keys</code>, <code>values</code>, 和 <code>entries</code> 方法，以及Python中的 <code>keys()</code>, <code>values()</code>, <code>items()</code>, 和 <code>get()</code> 方法等。</li>\n</ul>\n</li>\n<li><p><strong>用途和上下文</strong>:</p>\n<ul>\n<li>JavaScript对象常用于面向对象编程（OOP），并可以作为类的实例。</li>\n<li>Python字典更常用作数据结构，用于存储和检索复杂的数据关联。</li>\n</ul>\n</li>\n<li><p><strong>性能和优化</strong>:</p>\n<ul>\n<li>JavaScript引擎通常会对对象的属性访问进行优化，例如V8引擎的内联缓存。</li>\n<li>Python字典的性能取决于Python解释器的实现，如CPython，它使用哈希表来实现字典，这通常提供了快速的查找时间。</li>\n</ul>\n</li>\n</ol>\n<p>这些差异反映了两种语言的设计哲学和目标，JavaScript更多地被设计为一种用于Web的脚本语言，而Python则是一种通用的、高级的编程语言。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ad-note\">title: 哪些数据类型是对象？哪些不是对象？<br>- 对象是基于键值对的无序集合，其中的键（也称为属性名）是字符串，而值可以是任意数据类型，包括函数（作为方法）、其他对象、原始类型（如数字、字符串、布尔值）等。<br>\t- 对象是属性和方法的集合，属性用于描述对象状态，方法是封装在对象中的函数，用于执行操作或算法。两者都可以通过`.`或`[]`访问，但调用方法需要加`()`。<br>\t- ==函数本身也是一种对象，因为函数拥有name和desc属性==。<br>\t- <br>- 非对象：<br>\t- **基本数据类型（Primitive Types）**：包括 `number`、`string`、`boolean`、`undefined` 和 `null`。这些类型不是对象，它们是不可变的值。<br>    <br>\t- **Symbol**：ES6 引入的 Symbol 类型也不是对象，它用于创建唯一的键，常用于对象属性名。<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ad-note\">title: 如何创建对象？<br>- **字面量形式创建的对象**：可以直接使用大括号 `&#123;&#125;` 来定义一个对象，其中可以包含各种属性和方法。<br>    <br>    ```js<br>    const obj = &#123; key: &#x27;value&#x27;, method: function() &#123; /* ... */ &#125; &#125;;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>通过构造函数创建的对象</strong>：可以使用函数作为构造器，通过 <code>new</code> 关键字来创建对象实例。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>&#125;<br><span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&#x27;Alice&#x27;</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用 <code>Object.create()</code> 方法</strong>：可以指定一个原型对象，创建的新对象将继承原型对象的属性和方法。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> prototype = &#123; <span class=\"hljs-attr\">method</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-comment\">/* ... */</span> &#125; &#125;;<br><span class=\"hljs-keyword\">const</span> obj = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(prototype);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>类（Class）</strong>：ES6 引入了类语法，提供了一种更清晰的方式来定义对象和继承。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>  &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> animal = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Animal</span>(<span class=\"hljs-string\">&#x27;Lion&#x27;</span>);<br></code></pre></td></tr></table></figure></li>\n<li><p><strong>内置对象</strong>：JavaScript 提供了许多内置对象，如 <code>Array</code>、<code>Date</code>、<code>Function</code>、<code>Math</code>、<code>String</code> 等，它们都是对象。</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\"><br><br>### 原型和原型链<br><br>原型和原型链理解js面向对象和继承机制的核心，是实现对象间属性和方法共享的基础。<br><br>每个JavaScript对象，除了`null`，都有一个内部属性`Prototype`，它引用了另一个对象。这个被引用的对象就是当前对象的原型。<br>JavaScript的继承机制是基于原型的，这意味着每个对象都有一个原型（除了`null`），并且可以通过原型链访问属性和方法。<br>#### 继承机制<br>- 原型继承<br><br>当试图访问一个对象的属性或方法时，如果该对象本身不包含所查找的属性或方法，JavaScript引擎会沿着原型链向上查找，直到找到该属性或方法，或者到达原型链的末端。<br><br>- 默认继承<br><br>即使你不显式地设置一个对象的原型，它也会自动继承自`Object.prototype`，这是所有对象共享的基本原型，包含了如`toString`、`valueOf`等基本方法。<br><br>```js<br>const obj = &#123;&#125;<span class=\"hljs-comment\">;</span><br>console.log(obj.toString())<span class=\"hljs-comment\">; // &quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>在这个例子中，<code>obj</code>对象没有显式地设置原型，但它仍然可以调用<code>toString</code>方法，这是因为<code>toString</code>方法存在于<code>Object.prototype</code>上，<code>obj</code>隐式地继承了这个方法。</p>\n<h4 id=\"原型链好处——属性和方法共享\"><a href=\"#原型链好处——属性和方法共享\" class=\"headerlink\" title=\"原型链好处——属性和方法共享\"></a>原型链好处——属性和方法共享</h4><p>原型属性是属于该原型链的所有对象共享的，节约了内存，避免了重复定义。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ad-attention\">即使先创建对象，再给其原型添加属性，已经创建的对象也具有后添加的属性。<br></code></pre></td></tr></table></figure>\n<h3 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a>for循环</h3><p>遍历对象时，除了可以使用<code>for...in...</code>语法，还有一种<code>for...of...</code>语法。<br>两者区别：<br><code>for...of</code>循环用于遍历可迭代（Iterable）对象，如数组、字符串、Map、Set等。它按照元素的顺序访问每个元素的值，而不是键或索引。这对于需要访问集合中元素的实际值的场景非常有用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> fruits = [<span class=\"hljs-string\">&#x27;apple&#x27;</span>, <span class=\"hljs-string\">&#x27;banana&#x27;</span>, <span class=\"hljs-string\">&#x27;cherry&#x27;</span>]; <br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> fruit <span class=\"hljs-keyword\">of</span> fruits) &#123; <br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fruit); <br>\t&#125;<br></code></pre></td></tr></table></figure>\n<p><code>for...in</code>循环则用于枚举一个对象的所有可枚举属性的键。这在遍历对象的属性时非常有用，但它返回的是属性名，而不是属性值。对于数组来说，它会遍历数组的索引，包括稀疏数组中的未定义项以及继承的属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> person = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;John&#x27;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">30</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">&#x27;New York&#x27;</span> &#125;; <br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> prop <span class=\"hljs-keyword\">in</span> person) &#123; <br>\t<span class=\"hljs-keyword\">if</span> (person.<span class=\"hljs-title function_\">hasOwnProperty</span>(prop)) &#123; <br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;prop&#125;</span>: <span class=\"hljs-subst\">$&#123;person[prop]&#125;</span>`</span>); <br>\t&#125; <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h3><p>剩余参数语法可以将一个不定数量的参数表示为一个数组，用<code>...</code>表示。相当于python中的可变参数列表<code>*args</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> fruitInfo = &#123;<br>\t<span class=\"hljs-string\">&#x27;apple&#x27;</span> : <span class=\"hljs-number\">4</span>,<br>\t<span class=\"hljs-string\">&#x27;banana&#x27;</span>: <span class=\"hljs-number\">10</span>,<br>\t<span class=\"hljs-string\">&#x27;peach&#x27;</span>: <span class=\"hljs-number\">6</span>,<br>\t<span class=\"hljs-string\">&#x27;watermelon&#x27;</span>: <span class=\"hljs-number\">3</span>,<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">printFruitInfo</span>(<span class=\"hljs-params\">...fruits</span>)&#123;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> fruit <span class=\"hljs-keyword\">of</span> fruits)&#123;<br>\t\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`fruit: <span class=\"hljs-subst\">$&#123;fruit&#125;</span>, num: <span class=\"hljs-subst\">$&#123;fruitInfo[fruit]&#125;</span>`</span>);<br>\t&#125;<br>&#125;<br><span class=\"hljs-comment\">//调用函数</span><br><span class=\"hljs-title function_\">printFruitInfo</span>(<span class=\"hljs-string\">&#x27;apple&#x27;</span>, <span class=\"hljs-string\">&#x27;banana&#x27;</span>, <span class=\"hljs-string\">&#x27;peach&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>上述代码使用python表示时：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">fruit_info = &#123; <span class=\"hljs-string\">&#x27;apple&#x27;</span>: <span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;banana&#x27;</span>: <span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;peach&#x27;</span>: <span class=\"hljs-number\">6</span>, <span class=\"hljs-string\">&#x27;watermelon&#x27;</span>: <span class=\"hljs-number\">3</span>, &#125; <br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print_fruit_info</span>(<span class=\"hljs-params\">*fruits</span>): <br>\t<span class=\"hljs-keyword\">for</span> fruit <span class=\"hljs-keyword\">in</span> fruits: <br>\t\t<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;fruit: <span class=\"hljs-subst\">&#123;fruit&#125;</span>, num: <span class=\"hljs-subst\">&#123;fruit_info[fruit]&#125;</span>&quot;</span>) <br><span class=\"hljs-comment\"># 调用函数 </span><br>print_fruit_info(<span class=\"hljs-string\">&#x27;apple&#x27;</span>, <span class=\"hljs-string\">&#x27;banana&#x27;</span>, <span class=\"hljs-string\">&#x27;peach&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"单线程异步编程\"><a href=\"#单线程异步编程\" class=\"headerlink\" title=\"单线程异步编程\"></a>单线程异步编程</h3><p>js最初设计被用于进行web开发，通过事件处理机制来对用户事件进行监听和响应，js引擎使用异步架构。<br>在js中，异步（Asynchronous）编程是一种允许你的程序在等待某些耗时操作（如网络请求、文件读写、定时器、数据库查询等）完成的同时，继续执行其他任务的编程模式。异步编程是JavaScript处理并发和I&#x2F;O密集型操作的关键特性，它使得Web应用程序能够保持响应性和性能。</p>\n<p>与之相对的是同步（Synchronous）编程，其中程序会按顺序执行每一行代码，如果遇到耗时操作，程序会停下来等待这个操作完成，然后再继续执行下一行代码。这在单线程环境中（如JavaScript在浏览器中的执行环境）会导致阻塞，降低用户体验，尤其是在处理长时间运行的任务时。</p>\n<p>JavaScript使用事件循环（Event Loop）机制来支持异步编程。事件循环检查是否有待处理的事件或回调函数，如果有，就将它们加入到执行队列中，然后在当前任务完成后按顺序执行这些任务。这意味着，即使你的代码中包含了一些耗时操作，js引擎也不会停止执行其他代码，而是将这些耗时操作委托给操作系统或者其他线程去处理，一旦这些操作完成，再通过回调函数、Promise、async&#x2F;await等方式通知主执行线程。</p>\n<p>需要注意的是，js从设计之初就是一个单线程语言，即使看上去回调函数和主程序在并发执行，但其实都运行在一个主线程中。这种单线程异步编程方式的优点在于：</p>\n<ul>\n<li>不需要考虑线程同步和资源竞争；</li>\n<li>从源头上避免了线程间的切换，降低线程自身开销；</li>\n</ul>\n<h4 id=\"常见的异步编程方式\"><a href=\"#常见的异步编程方式\" class=\"headerlink\" title=\"常见的异步编程方式\"></a>常见的异步编程方式</h4><ol>\n<li><p><strong>回调函数（Callback）</strong>：将一个函数作为参数传递到另一个函数中，并在另一个函数中调用，这个函数就是回调函数（两个条件，外部调用，内部定义）。回调函数需要预先定义好，在发起异步操作时，同时提供一个回调函数，当异步操作完成时调用这个函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//setTimeout模仿异步操作，两秒后调用回调函数callback</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-params\">callback</span>) &#123; <br>\t<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123; <br>\t\t<span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-string\">&#x27;Hello from the server!&#x27;</span>; <br>\t\t<span class=\"hljs-title function_\">callback</span>(data); <br>\t\t&#125;, <span class=\"hljs-number\">2000</span>); <br>\t&#125;<br><span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123; <br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data); <br>\t&#125;);<br></code></pre></td></tr></table></figure>\n<p>回调函数缺点：当需要依次执行多个异步操作时，容易陷入回调地狱。</p>\n</li>\n<li><p><strong>Promise</strong>：一种更为现代的处理异步操作的方法，允许以<strong>链式</strong>调用的方式处理异步操作的结果，通过链式调用避免层层嵌套，提升可读性。js中的fetch API就是一个很好的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>)<br>\t.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>)=&gt;</span>response.<span class=\"hljs-title function_\">json</span>())<br>\t.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">json</span>)=&gt;</span>&#123;<br>\t\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(json);<br>\t&#125;)<br>\t.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>)=&gt;</span>&#123;<br>\t\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(error);<br>\t&#125;)<br>\t<span class=\"hljs-title function_\">finally</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;<br>\t\t<span class=\"hljs-title function_\">stopLoadingAnimation</span>();              <span class=\"hljs-comment\">//类似try-catch-finally结构</span><br>\t&#125;);<br><br></code></pre></td></tr></table></figure>\n<p>Promise是ES6中引入的用于简化异步编程的构造。Promise对象代表一个最终可能完成或失败的异步操作，它有三种状态：pending（等待中）、fulfilled（已完成）和rejected（已拒绝）。<br>从字面理解<code>Promise</code>——承诺会在未来某个时刻返回数据，异步函数可以理解为返回值为Promise对象的函数。</p>\n</li>\n<li><p><strong>Async&#x2F;Await</strong>：基于Promise的语法糖（不改变实际功能，但提升程序可读性），使异步代码看起来更像同步代码，提高了代码的可读性和可维护性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>)&#123;  <span class=\"hljs-comment\">//使用async关键字将函数标记为异步函数</span><br>\t<span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&quot;http://&quot;</span>) <span class=\"hljs-comment\">//使用await代替then </span><br>\t<span class=\"hljs-keyword\">const</span> json = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(json);<br>&#125;  <br><span class=\"hljs-title function_\">f</span>(); <br></code></pre></td></tr></table></figure>\n<p>异步编程虽然增加了代码的复杂性，但它是构建高性能、高响应性的现代Web应用所必需的。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript简介\"><a href=\"#JavaScript简介\" class=\"headerlink\" title=\"JavaScript简介\"></a>JavaScript简介</h1><h2 id=\"语言规范\"><a href=\"#语言规范\" class=\"headerlink\" title=\"语言规范\"></a>语言规范</h2><p>JavaScript语言遵循ECMAScript规范（简称ES），ECMA即欧洲计算机协会，该规范定义了JavaScript（以下统一使用js缩写）语言的核心特性，确保不同环境下的js实现（比如浏览器内置js引擎、Nodejs、其他服务器端js运行时等）的一致性和互操作性。ES6或ES2015（2015年6月发行）是该规范发行以来的一个重要里程碑，也是主流浏览器基本支持的版本。</p>\n<h2 id=\"特性和应用场景\"><a href=\"#特性和应用场景\" class=\"headerlink\" title=\"特性和应用场景\"></a>特性和应用场景</h2><ol>\n<li>基于原型的面向对象语言，在动态修改和扩展对象上更加灵活（弱化了结构和可维护性）。</li>\n</ol>\n<ul>\n<li>与传统的面向对象编程范式（Java&#x2F;C++&#x2F;C#等）的主要区别：<ul>\n<li>创建机制：创建对象时，无需定义类模板，通过从对已有对象的克隆或引用创建；</li>\n<li>继承机制：直接从原型对象继承属性和方法，通过原型链实现；</li>\n<li>方法共享：所有继承自原型的对象共享同一个方法的引用，减少内存使用。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>动态弱类型语言<br>不需要显式声明对象类型（可使用var关键字），并且可在运行时修改对象类型（比如将一个对象从数字改成字符串），类型转换是隐式的。</li>\n</ol>\n<ul>\n<li>动态vs静态：静态类型语言指代码在编译时检测变量类型，从而避免可能的类型错误，典型语言如C、C++、Java、C#；动态类型语言则是在运行时才检查变量的类型，意味着你可以随时改变变量的类型，代价是降低了程序的稳定性和安全性，代表性语言Python、Ruby、Javascript和PHP。</li>\n<li>弱类型vs强类型：强类型语言中，变量的类型在定义和检查时都比较严格，一旦赋予类型，不支持隐式地类型转换（自动转换），如果要转换，必须显式转换，典型例子：Java、C# 和 Rust；弱类型语言中，类型检查较为宽松，可以进行变量类型自动转换（隐式转换），比如数字和字符串可以相互转换，或者布尔值可以转换为数字，典型例子：早期Javascript和Visual Basic。<ul>\n<li>许多现代编程语言（如 TypeScript 或 Python 3）都在向更强类型的方向发展，即使它们传统上被认为是弱类型或动态类型的。这些语言通过引入类型注解、静态类型检查工具或其他机制来增强类型安全性，同时保持了一定程度的灵活性。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"主要功能和应用\"><a href=\"#主要功能和应用\" class=\"headerlink\" title=\"主要功能和应用\"></a>主要功能和应用</h2><p>了解js语言的功能和用途有助于掌握js语言的能力边界，在实际解决问题的过程中更好地选用语言、框架、技术栈，提升开发效率、降低开发难度。</p>\n<ol>\n<li><strong>web（前段）开发</strong><ul>\n<li><strong>动态网页</strong>：JavaScript可以用来创建交互式的网页元素，如下拉菜单、弹出窗口、表单验证等。<blockquote>\n<p>为什么可以使用js实现交互式动态网页？<br>js运行在浏览器端，借助浏览器DOM操作实现对网页元素的访问和修改；通过事件处理机制实现对用户操作的监听和响应；通过AJAX异步请求等方式和服务器端进行通信，访问后端数据等。</p>\n</blockquote>\n</li>\n<li><strong>DOM操作</strong>：JavaScript可以动态地修改HTML文档中的内容和样式，从而实现页面的实时更新。</li>\n<li><strong>AJAX</strong>：通过异步数据请求，JavaScript可以实现在不刷新整个页面的情况下更新部分内容，提升用户体验。</li>\n<li><strong>框架和库</strong>：如React、Angular和Vue.js等前端框架，它们基于JavaScript，用于构建复杂的Web应用程序。</li>\n</ul>\n</li>\n<li><strong>服务器端开发</strong>：<ul>\n<li><strong>Node.js</strong>：使开发者能够使用JavaScript进行服务器端编程，从而实现全栈JavaScript开发。</li>\n<li><strong>数据库操作</strong>：通过Node.js，JavaScript可以与各种数据库（如MongoDB、MySQL）进行交互，实现数据存储和检索。</li>\n</ul>\n</li>\n<li><strong>游戏开发</strong>：<ul>\n<li><strong>Canvas API</strong>：用于创建2D图形和动画，常用于浏览器游戏开发。</li>\n<li><strong>WebGL</strong>：用于3D图形渲染，使得复杂的游戏和可视化应用成为可能。</li>\n</ul>\n</li>\n<li><strong>移动应用开发</strong>：<ul>\n<li><strong>React Native</strong>、<strong>Ionic</strong>和<strong>Cordova</strong>等框架允许使用JavaScript开发跨平台的移动应用。</li>\n</ul>\n</li>\n<li><strong>桌面应用程序</strong>：<ul>\n<li><strong>Electron</strong>框架使得使用Web技术（HTML、CSS和JavaScript）开发跨平台的桌面应用程序成为可能。</li>\n</ul>\n</li>\n<li><strong>物联网（IoT）</strong>：<ul>\n<li><strong>Node-RED</strong>：一个基于Node.js的流媒体处理工具，用于构建物联网应用的数据流网络。</li>\n</ul>\n</li>\n<li><strong>数据可视化</strong>：<ul>\n<li><strong>D3.js</strong>等库可以帮助开发者从数据中创建复杂的可视化图表和图形。</li>\n</ul>\n</li>\n<li><strong>自动化任务</strong>：<ul>\n<li>使用Node.js，JavaScript可以编写自动化脚本来执行服务器管理、文件操作、构建过程等任务。</li>\n</ul>\n</li>\n<li><strong>机器学习</strong>：<ul>\n<li><strong>TensorFlow.js</strong>：允许在浏览器或Node.js环境中执行机器学习模型。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><h2 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h2><p>vscode（编辑器），Nodejs（解释运行），google浏览器开发者工具（自带js引擎，调试）</p>\n<h2 id=\"命名习惯\"><a href=\"#命名习惯\" class=\"headerlink\" title=\"命名习惯\"></a>命名习惯</h2><ul>\n<li>变量：驼峰命名法</li>\n<li>常量：全大写，下划线间隔</li>\n<li>函数：动词在前，驼峰命名法</li>\n<li>文件名：全小写，下划线间隔</li>\n</ul>\n<h2 id=\"教程参考\"><a href=\"#教程参考\" class=\"headerlink\" title=\"教程参考\"></a>教程参考</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/JavaScript_basics\">JavaScript 基础 - 学习 Web 开发 | MDN (mozilla.org)</a></li>\n<li><a href=\"https://www.byhy.net/web/js/01/\">Javascript 简介 - 白月黑羽 (byhy.net)</a></li>\n</ul>\n<h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><p>如果你和我一样平时使用python较多，那么以下知识点你可能需要关注一下。</p>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><blockquote>\n<p>let和var关键字区别<br>在JavaScript中，<code>let</code> 和 <code>var</code> 都用于声明变量，但它们之间有几个重要的区别：</p>\n</blockquote>\n<ol>\n<li><p><strong>作用域</strong>:</p>\n<ul>\n<li><code>var</code> 声明的变量具有函数作用域或全局作用域。这意味着在一个函数内部声明的变量在整个函数内部都是可见的，而在函数外部声明的变量则在整个脚本或全局范围内可见。</li>\n<li><code>let</code> 声明的变量具有块级作用域。这意味着变量仅在其被声明的代码块（由 <code>&#123;&#125;</code> 包围的区域，如循环或条件语句）内可见。</li>\n</ul>\n</li>\n<li><p><strong>变量提升 (Hoisting)</strong>:</p>\n<ul>\n<li><code>var</code> 声明的变量会被提升至作用域的顶部，即在函数或全局作用域的最开始处声明，尽管实际声明可能出现在作用域内的任何位置。</li>\n<li><code>let</code> 声明的变量不会被提升。变量必须在使用之前声明，否则会抛出引用错误。</li>\n</ul>\n</li>\n<li><p><strong>重复声明</strong>:</p>\n<ul>\n<li>使用 <code>var</code> 可以在同一作用域内多次声明同一个变量名，后一个声明会覆盖前一个。</li>\n<li>使用 <code>let</code> 在同一作用域内不允许重复声明同一个变量名，尝试这样做会导致语法错误。</li>\n</ul>\n</li>\n<li><p><strong>暂时性死区 (Temporal Dead Zone)</strong>:</p>\n<ul>\n<li><code>var</code> 声明的变量在提升之后就可以访问，尽管访问时值为 <code>undefined</code>。</li>\n<li><code>let</code> 声明的变量在声明之前访问会抛出错误，这是因为变量存在于暂时性死区中直到其声明点。</li>\n</ul>\n</li>\n<li><p><strong>全局属性</strong>:</p>\n<ul>\n<li>如果在全局作用域中使用 <code>var</code> 声明变量，该变量会自动成为全局对象（通常是 <code>window</code> 对象在浏览器环境中）的属性。</li>\n<li>使用 <code>let</code> 在全局作用域声明的变量不会成为全局对象的属性。</li>\n</ul>\n</li>\n</ol>\n<p>总结来说，<code>let</code> 提供了更严格的变量管理，增强了代码的可预测性和维护性。因此，现代JavaScript编码实践中通常推荐使用 <code>let</code> 而不是 <code>var</code>。同时，随着ES6的普及，<code>const</code> 也被广泛用于声明不可变的常量。</p>\n<h3 id=\"字符串-引号\"><a href=\"#字符串-引号\" class=\"headerlink\" title=\"字符串 引号\"></a>字符串 引号</h3><p>js中的字符串可以用单引号、双引号、反引号，以下定义都可以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-string\">&#x27;字符串&#x27;</span><br><span class=\"hljs-string\">&quot;字符串&quot;</span><br><span class=\"hljs-string\">`字符串`</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"逻辑操作\"><a href=\"#逻辑操作\" class=\"headerlink\" title=\"逻辑操作\"></a>逻辑操作</h3><p>松散相等比较和严格相等比较</p>\n<ul>\n<li>严格相等比较：<code>1===1</code>返回true， <code>1===&#39;1&#39;</code>返回false</li>\n<li>松散相等比较：<code>1==&#39;1&#39;</code>返回true，在比较时会尝试转化为同种类型进行比较<br>不相等同理。</li>\n</ul>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>我们看到的js中通过字面量语法创建的对象和python中的字典类型在形式上有些相似，都是键值对的组合，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> student&#123;<br>\t<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;张三&#x27;</span>，<br>\t<span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">23</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>并且js中的对象也支持通过<code>[]</code>访问对象的属性：<code>student[&#39;name&#39;]</code>，但两者在很多细节上存在一些关键区别：</p>\n<ol>\n<li><p><strong>语法差异</strong>:</p>\n<ul>\n<li>在JavaScript中，对象通常使用<strong>字面量</strong>语法定义，例如 <code>&#123;key: value&#125;</code> ，或通过构造函数 <code>new Object()</code> 创建。</li>\n<li>在Python中，字典使用花括号 <code>&#123;&#125;</code> 并且键值对之间用冒号 <code>:</code> 分隔。</li>\n</ul>\n</li>\n<li><p><strong>属性访问</strong>:</p>\n<ul>\n<li>JavaScript中，对象的属性可以通过点符号 <code>.</code> 或方括号 <code>[]</code> 访问，例如 <code>obj.key</code> 或 <code>obj[&#39;key&#39;]</code>（适合属性名中有空格等特殊字符、属性名为变量的情况）。</li>\n<li>Python中，字典的元素只能通过方括号访问，例如 <code>dict[&#39;key&#39;]</code>。你不能使用点符号访问字典元素。</li>\n</ul>\n</li>\n<li><p><strong>动态属性</strong>:</p>\n<ul>\n<li>JavaScript对象允许动态添加属性，即可以在运行时向对象添加新的键值对。</li>\n<li>Python字典同样支持动态添加键值对。</li>\n</ul>\n</li>\n<li><p><strong>原型继承</strong>:<br>JavaScript对象基于原型继承，这意味着一个对象可以从另一个对象继承属性和方法。这使得JavaScript对象具有层次结构和动态性。</p>\n<ul>\n<li>Python字典没有这样的原型链概念，它们只包含自己的键值对，并不从其他字典继承任何东西。</li>\n</ul>\n</li>\n<li><p><strong>内置方法和功能</strong>:</p>\n<ul>\n<li>JavaScript对象和Python字典都有一系列内置的方法用于操作数据，但具体的方法可能不同。</li>\n<li>例如，JavaScript中的 <code>hasOwnProperty</code>, <code>keys</code>, <code>values</code>, 和 <code>entries</code> 方法，以及Python中的 <code>keys()</code>, <code>values()</code>, <code>items()</code>, 和 <code>get()</code> 方法等。</li>\n</ul>\n</li>\n<li><p><strong>用途和上下文</strong>:</p>\n<ul>\n<li>JavaScript对象常用于面向对象编程（OOP），并可以作为类的实例。</li>\n<li>Python字典更常用作数据结构，用于存储和检索复杂的数据关联。</li>\n</ul>\n</li>\n<li><p><strong>性能和优化</strong>:</p>\n<ul>\n<li>JavaScript引擎通常会对对象的属性访问进行优化，例如V8引擎的内联缓存。</li>\n<li>Python字典的性能取决于Python解释器的实现，如CPython，它使用哈希表来实现字典，这通常提供了快速的查找时间。</li>\n</ul>\n</li>\n</ol>\n<p>这些差异反映了两种语言的设计哲学和目标，JavaScript更多地被设计为一种用于Web的脚本语言，而Python则是一种通用的、高级的编程语言。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ad-note\">title: 哪些数据类型是对象？哪些不是对象？<br>- 对象是基于键值对的无序集合，其中的键（也称为属性名）是字符串，而值可以是任意数据类型，包括函数（作为方法）、其他对象、原始类型（如数字、字符串、布尔值）等。<br>\t- 对象是属性和方法的集合，属性用于描述对象状态，方法是封装在对象中的函数，用于执行操作或算法。两者都可以通过`.`或`[]`访问，但调用方法需要加`()`。<br>\t- ==函数本身也是一种对象，因为函数拥有name和desc属性==。<br>\t- <br>- 非对象：<br>\t- **基本数据类型（Primitive Types）**：包括 `number`、`string`、`boolean`、`undefined` 和 `null`。这些类型不是对象，它们是不可变的值。<br>    <br>\t- **Symbol**：ES6 引入的 Symbol 类型也不是对象，它用于创建唯一的键，常用于对象属性名。<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ad-note\">title: 如何创建对象？<br>- **字面量形式创建的对象**：可以直接使用大括号 `&#123;&#125;` 来定义一个对象，其中可以包含各种属性和方法。<br>    <br>    ```js<br>    const obj = &#123; key: &#x27;value&#x27;, method: function() &#123; /* ... */ &#125; &#125;;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>通过构造函数创建的对象</strong>：可以使用函数作为构造器，通过 <code>new</code> 关键字来创建对象实例。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>&#125;<br><span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&#x27;Alice&#x27;</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用 <code>Object.create()</code> 方法</strong>：可以指定一个原型对象，创建的新对象将继承原型对象的属性和方法。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> prototype = &#123; <span class=\"hljs-attr\">method</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-comment\">/* ... */</span> &#125; &#125;;<br><span class=\"hljs-keyword\">const</span> obj = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(prototype);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>类（Class）</strong>：ES6 引入了类语法，提供了一种更清晰的方式来定义对象和继承。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>  &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> animal = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Animal</span>(<span class=\"hljs-string\">&#x27;Lion&#x27;</span>);<br></code></pre></td></tr></table></figure></li>\n<li><p><strong>内置对象</strong>：JavaScript 提供了许多内置对象，如 <code>Array</code>、<code>Date</code>、<code>Function</code>、<code>Math</code>、<code>String</code> 等，它们都是对象。</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\"><br><br>### 原型和原型链<br><br>原型和原型链理解js面向对象和继承机制的核心，是实现对象间属性和方法共享的基础。<br><br>每个JavaScript对象，除了`null`，都有一个内部属性`Prototype`，它引用了另一个对象。这个被引用的对象就是当前对象的原型。<br>JavaScript的继承机制是基于原型的，这意味着每个对象都有一个原型（除了`null`），并且可以通过原型链访问属性和方法。<br>#### 继承机制<br>- 原型继承<br><br>当试图访问一个对象的属性或方法时，如果该对象本身不包含所查找的属性或方法，JavaScript引擎会沿着原型链向上查找，直到找到该属性或方法，或者到达原型链的末端。<br><br>- 默认继承<br><br>即使你不显式地设置一个对象的原型，它也会自动继承自`Object.prototype`，这是所有对象共享的基本原型，包含了如`toString`、`valueOf`等基本方法。<br><br>```js<br>const obj = &#123;&#125;<span class=\"hljs-comment\">;</span><br>console.log(obj.toString())<span class=\"hljs-comment\">; // &quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>在这个例子中，<code>obj</code>对象没有显式地设置原型，但它仍然可以调用<code>toString</code>方法，这是因为<code>toString</code>方法存在于<code>Object.prototype</code>上，<code>obj</code>隐式地继承了这个方法。</p>\n<h4 id=\"原型链好处——属性和方法共享\"><a href=\"#原型链好处——属性和方法共享\" class=\"headerlink\" title=\"原型链好处——属性和方法共享\"></a>原型链好处——属性和方法共享</h4><p>原型属性是属于该原型链的所有对象共享的，节约了内存，避免了重复定义。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ad-attention\">即使先创建对象，再给其原型添加属性，已经创建的对象也具有后添加的属性。<br></code></pre></td></tr></table></figure>\n<h3 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a>for循环</h3><p>遍历对象时，除了可以使用<code>for...in...</code>语法，还有一种<code>for...of...</code>语法。<br>两者区别：<br><code>for...of</code>循环用于遍历可迭代（Iterable）对象，如数组、字符串、Map、Set等。它按照元素的顺序访问每个元素的值，而不是键或索引。这对于需要访问集合中元素的实际值的场景非常有用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> fruits = [<span class=\"hljs-string\">&#x27;apple&#x27;</span>, <span class=\"hljs-string\">&#x27;banana&#x27;</span>, <span class=\"hljs-string\">&#x27;cherry&#x27;</span>]; <br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> fruit <span class=\"hljs-keyword\">of</span> fruits) &#123; <br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fruit); <br>\t&#125;<br></code></pre></td></tr></table></figure>\n<p><code>for...in</code>循环则用于枚举一个对象的所有可枚举属性的键。这在遍历对象的属性时非常有用，但它返回的是属性名，而不是属性值。对于数组来说，它会遍历数组的索引，包括稀疏数组中的未定义项以及继承的属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> person = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;John&#x27;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">30</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">&#x27;New York&#x27;</span> &#125;; <br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> prop <span class=\"hljs-keyword\">in</span> person) &#123; <br>\t<span class=\"hljs-keyword\">if</span> (person.<span class=\"hljs-title function_\">hasOwnProperty</span>(prop)) &#123; <br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;prop&#125;</span>: <span class=\"hljs-subst\">$&#123;person[prop]&#125;</span>`</span>); <br>\t&#125; <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h3><p>剩余参数语法可以将一个不定数量的参数表示为一个数组，用<code>...</code>表示。相当于python中的可变参数列表<code>*args</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> fruitInfo = &#123;<br>\t<span class=\"hljs-string\">&#x27;apple&#x27;</span> : <span class=\"hljs-number\">4</span>,<br>\t<span class=\"hljs-string\">&#x27;banana&#x27;</span>: <span class=\"hljs-number\">10</span>,<br>\t<span class=\"hljs-string\">&#x27;peach&#x27;</span>: <span class=\"hljs-number\">6</span>,<br>\t<span class=\"hljs-string\">&#x27;watermelon&#x27;</span>: <span class=\"hljs-number\">3</span>,<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">printFruitInfo</span>(<span class=\"hljs-params\">...fruits</span>)&#123;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> fruit <span class=\"hljs-keyword\">of</span> fruits)&#123;<br>\t\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`fruit: <span class=\"hljs-subst\">$&#123;fruit&#125;</span>, num: <span class=\"hljs-subst\">$&#123;fruitInfo[fruit]&#125;</span>`</span>);<br>\t&#125;<br>&#125;<br><span class=\"hljs-comment\">//调用函数</span><br><span class=\"hljs-title function_\">printFruitInfo</span>(<span class=\"hljs-string\">&#x27;apple&#x27;</span>, <span class=\"hljs-string\">&#x27;banana&#x27;</span>, <span class=\"hljs-string\">&#x27;peach&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>上述代码使用python表示时：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">fruit_info = &#123; <span class=\"hljs-string\">&#x27;apple&#x27;</span>: <span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">&#x27;banana&#x27;</span>: <span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&#x27;peach&#x27;</span>: <span class=\"hljs-number\">6</span>, <span class=\"hljs-string\">&#x27;watermelon&#x27;</span>: <span class=\"hljs-number\">3</span>, &#125; <br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print_fruit_info</span>(<span class=\"hljs-params\">*fruits</span>): <br>\t<span class=\"hljs-keyword\">for</span> fruit <span class=\"hljs-keyword\">in</span> fruits: <br>\t\t<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;fruit: <span class=\"hljs-subst\">&#123;fruit&#125;</span>, num: <span class=\"hljs-subst\">&#123;fruit_info[fruit]&#125;</span>&quot;</span>) <br><span class=\"hljs-comment\"># 调用函数 </span><br>print_fruit_info(<span class=\"hljs-string\">&#x27;apple&#x27;</span>, <span class=\"hljs-string\">&#x27;banana&#x27;</span>, <span class=\"hljs-string\">&#x27;peach&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"单线程异步编程\"><a href=\"#单线程异步编程\" class=\"headerlink\" title=\"单线程异步编程\"></a>单线程异步编程</h3><p>js最初设计被用于进行web开发，通过事件处理机制来对用户事件进行监听和响应，js引擎使用异步架构。<br>在js中，异步（Asynchronous）编程是一种允许你的程序在等待某些耗时操作（如网络请求、文件读写、定时器、数据库查询等）完成的同时，继续执行其他任务的编程模式。异步编程是JavaScript处理并发和I&#x2F;O密集型操作的关键特性，它使得Web应用程序能够保持响应性和性能。</p>\n<p>与之相对的是同步（Synchronous）编程，其中程序会按顺序执行每一行代码，如果遇到耗时操作，程序会停下来等待这个操作完成，然后再继续执行下一行代码。这在单线程环境中（如JavaScript在浏览器中的执行环境）会导致阻塞，降低用户体验，尤其是在处理长时间运行的任务时。</p>\n<p>JavaScript使用事件循环（Event Loop）机制来支持异步编程。事件循环检查是否有待处理的事件或回调函数，如果有，就将它们加入到执行队列中，然后在当前任务完成后按顺序执行这些任务。这意味着，即使你的代码中包含了一些耗时操作，js引擎也不会停止执行其他代码，而是将这些耗时操作委托给操作系统或者其他线程去处理，一旦这些操作完成，再通过回调函数、Promise、async&#x2F;await等方式通知主执行线程。</p>\n<p>需要注意的是，js从设计之初就是一个单线程语言，即使看上去回调函数和主程序在并发执行，但其实都运行在一个主线程中。这种单线程异步编程方式的优点在于：</p>\n<ul>\n<li>不需要考虑线程同步和资源竞争；</li>\n<li>从源头上避免了线程间的切换，降低线程自身开销；</li>\n</ul>\n<h4 id=\"常见的异步编程方式\"><a href=\"#常见的异步编程方式\" class=\"headerlink\" title=\"常见的异步编程方式\"></a>常见的异步编程方式</h4><ol>\n<li><p><strong>回调函数（Callback）</strong>：将一个函数作为参数传递到另一个函数中，并在另一个函数中调用，这个函数就是回调函数（两个条件，外部调用，内部定义）。回调函数需要预先定义好，在发起异步操作时，同时提供一个回调函数，当异步操作完成时调用这个函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//setTimeout模仿异步操作，两秒后调用回调函数callback</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-params\">callback</span>) &#123; <br>\t<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123; <br>\t\t<span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-string\">&#x27;Hello from the server!&#x27;</span>; <br>\t\t<span class=\"hljs-title function_\">callback</span>(data); <br>\t\t&#125;, <span class=\"hljs-number\">2000</span>); <br>\t&#125;<br><span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> &#123; <br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data); <br>\t&#125;);<br></code></pre></td></tr></table></figure>\n<p>回调函数缺点：当需要依次执行多个异步操作时，容易陷入回调地狱。</p>\n</li>\n<li><p><strong>Promise</strong>：一种更为现代的处理异步操作的方法，允许以<strong>链式</strong>调用的方式处理异步操作的结果，通过链式调用避免层层嵌套，提升可读性。js中的fetch API就是一个很好的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>)<br>\t.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>)=&gt;</span>response.<span class=\"hljs-title function_\">json</span>())<br>\t.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">json</span>)=&gt;</span>&#123;<br>\t\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(json);<br>\t&#125;)<br>\t.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>)=&gt;</span>&#123;<br>\t\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(error);<br>\t&#125;)<br>\t<span class=\"hljs-title function_\">finally</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;<br>\t\t<span class=\"hljs-title function_\">stopLoadingAnimation</span>();              <span class=\"hljs-comment\">//类似try-catch-finally结构</span><br>\t&#125;);<br><br></code></pre></td></tr></table></figure>\n<p>Promise是ES6中引入的用于简化异步编程的构造。Promise对象代表一个最终可能完成或失败的异步操作，它有三种状态：pending（等待中）、fulfilled（已完成）和rejected（已拒绝）。<br>从字面理解<code>Promise</code>——承诺会在未来某个时刻返回数据，异步函数可以理解为返回值为Promise对象的函数。</p>\n</li>\n<li><p><strong>Async&#x2F;Await</strong>：基于Promise的语法糖（不改变实际功能，但提升程序可读性），使异步代码看起来更像同步代码，提高了代码的可读性和可维护性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>)&#123;  <span class=\"hljs-comment\">//使用async关键字将函数标记为异步函数</span><br>\t<span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&quot;http://&quot;</span>) <span class=\"hljs-comment\">//使用await代替then </span><br>\t<span class=\"hljs-keyword\">const</span> json = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(json);<br>&#125;  <br><span class=\"hljs-title function_\">f</span>(); <br></code></pre></td></tr></table></figure>\n<p>异步编程虽然增加了代码的复杂性，但它是构建高性能、高响应性的现代Web应用所必需的。</p>\n</li>\n</ol>\n"},{"title":"了解cookie-session-token","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2024-07-01T05:22:00.000Z","password":null,"summary":null,"_content":"\n\n### 基础cookie\n\ncookie：浏览器给首次服务器发送http请求时进行用户登录验证，用户名密码验证成功，服务器在响应时会set-cookie也就是cookie设置（包含name-value属性，理解为用户名和密码），浏览器收到响应后将cookie保存起来（通过DevTools开发者工具-application-cookie可查看，**保存在浏览器中**），后面浏览器发送的每一个HTTP请求都会附上cookie（作为请求头的一部分）。\n\n问题：如果把用户名密码存在cookie中，当电脑被黑，会泄露信息很不安全。\n\n解决方案：在cookie中不存放用户名密码，而是session id\n\n### 基于cookie的session\n\nsession：将浏览器访问服务器行为看作会话，用户登录验证通过后，服务器生成新的session对象，包含{SessionId: xxPSnj01(无规律字符串，唯一), Max-Age:会话结束时间对应cookie有效期…}（**保存在服务器自身数据库中**），在响应请求进行set-cookie时将上述信息放到cookie中（此时不包含用户名和密码），浏览器拿到cookie后保存（黑客入侵拿到SessionId无法推断用户名密码），在下次请求时放到请求头cookie中（DevTools-Network，对应请求的Headers中包含cookies），如果黑客修改了SessionID，浏览器可以通过签名知道。cookie失效后，浏览器会自动删除该cookie。用户logout时，会话结束，服务器保存的session会清除。\n\n问题：大量用户同时访问服务器时，产生大量sessionId，\n\n- 性能问题\n\n因为，验证请求是根据sessionid 到数据库中查找session表的，而数据库操作是服务端常见的性能瓶颈，尤其是当用户量比较大的时候。\n\n- 扩展性问题\n\n当系统用户特别多的时候，后端处理请求的服务端通常由多个，部署在多个节点上。 但是多个节点都要访问session表，这样就要求数据库服务能够被多个节点访问，不方便切分数据库以提高性能。\n\n解决方案：JWT（Json Web Token）\n\n### Token\n\n![](image-20240701133048798.png)\n\n\n用户登录验证成功后，服务器产生一个JWT返回给浏览器，服务器自身不保存JWT，只保存一个JWT签名的密文，浏览器以cookie或storage的方式存储JWT（**JWT保存在浏览器，服务器保保存一个密钥**secret key）。再次发送请求时附上JWT。\n\nJWT由 header.payload.signature组成：（token中三个字符串由.分割）\n\n- header：生成签名的算法，一般是哈希算法\n- payload：数据，比如有效期\n- signature：签名信息，header和payload分别通过base64编码（编码和加密的区别，编码可以解码），服务器保存的密钥secret key和两段编码进行算法运算得到签名信息。\n\n三部分相关联，修改其中一部分，服务器计算得到的签名就不一致，一定程度上保证安全。Token相当于访问服务器的令牌。\n\n综上，cookie是一种数据载体。","source":"_posts/了解cookie-session-token.md","raw":"---\ntitle: 了解cookie-session-token\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2024-07-01 13:22:00\npassword: \nsummary: \ntags:\n  - web\ncategories:\n---\n\n\n### 基础cookie\n\ncookie：浏览器给首次服务器发送http请求时进行用户登录验证，用户名密码验证成功，服务器在响应时会set-cookie也就是cookie设置（包含name-value属性，理解为用户名和密码），浏览器收到响应后将cookie保存起来（通过DevTools开发者工具-application-cookie可查看，**保存在浏览器中**），后面浏览器发送的每一个HTTP请求都会附上cookie（作为请求头的一部分）。\n\n问题：如果把用户名密码存在cookie中，当电脑被黑，会泄露信息很不安全。\n\n解决方案：在cookie中不存放用户名密码，而是session id\n\n### 基于cookie的session\n\nsession：将浏览器访问服务器行为看作会话，用户登录验证通过后，服务器生成新的session对象，包含{SessionId: xxPSnj01(无规律字符串，唯一), Max-Age:会话结束时间对应cookie有效期…}（**保存在服务器自身数据库中**），在响应请求进行set-cookie时将上述信息放到cookie中（此时不包含用户名和密码），浏览器拿到cookie后保存（黑客入侵拿到SessionId无法推断用户名密码），在下次请求时放到请求头cookie中（DevTools-Network，对应请求的Headers中包含cookies），如果黑客修改了SessionID，浏览器可以通过签名知道。cookie失效后，浏览器会自动删除该cookie。用户logout时，会话结束，服务器保存的session会清除。\n\n问题：大量用户同时访问服务器时，产生大量sessionId，\n\n- 性能问题\n\n因为，验证请求是根据sessionid 到数据库中查找session表的，而数据库操作是服务端常见的性能瓶颈，尤其是当用户量比较大的时候。\n\n- 扩展性问题\n\n当系统用户特别多的时候，后端处理请求的服务端通常由多个，部署在多个节点上。 但是多个节点都要访问session表，这样就要求数据库服务能够被多个节点访问，不方便切分数据库以提高性能。\n\n解决方案：JWT（Json Web Token）\n\n### Token\n\n![](image-20240701133048798.png)\n\n\n用户登录验证成功后，服务器产生一个JWT返回给浏览器，服务器自身不保存JWT，只保存一个JWT签名的密文，浏览器以cookie或storage的方式存储JWT（**JWT保存在浏览器，服务器保保存一个密钥**secret key）。再次发送请求时附上JWT。\n\nJWT由 header.payload.signature组成：（token中三个字符串由.分割）\n\n- header：生成签名的算法，一般是哈希算法\n- payload：数据，比如有效期\n- signature：签名信息，header和payload分别通过base64编码（编码和加密的区别，编码可以解码），服务器保存的密钥secret key和两段编码进行算法运算得到签名信息。\n\n三部分相关联，修改其中一部分，服务器计算得到的签名就不一致，一定程度上保证安全。Token相当于访问服务器的令牌。\n\n综上，cookie是一种数据载体。","slug":"了解cookie-session-token","published":1,"updated":"2024-07-01T05:30:59.073Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly2zhjn3000cxdqr2qy180q8","content":"<h3 id=\"基础cookie\"><a href=\"#基础cookie\" class=\"headerlink\" title=\"基础cookie\"></a>基础cookie</h3><p>cookie：浏览器给首次服务器发送http请求时进行用户登录验证，用户名密码验证成功，服务器在响应时会set-cookie也就是cookie设置（包含name-value属性，理解为用户名和密码），浏览器收到响应后将cookie保存起来（通过DevTools开发者工具-application-cookie可查看，<strong>保存在浏览器中</strong>），后面浏览器发送的每一个HTTP请求都会附上cookie（作为请求头的一部分）。</p>\n<p>问题：如果把用户名密码存在cookie中，当电脑被黑，会泄露信息很不安全。</p>\n<p>解决方案：在cookie中不存放用户名密码，而是session id</p>\n<h3 id=\"基于cookie的session\"><a href=\"#基于cookie的session\" class=\"headerlink\" title=\"基于cookie的session\"></a>基于cookie的session</h3><p>session：将浏览器访问服务器行为看作会话，用户登录验证通过后，服务器生成新的session对象，包含{SessionId: xxPSnj01(无规律字符串，唯一), Max-Age:会话结束时间对应cookie有效期…}（<strong>保存在服务器自身数据库中</strong>），在响应请求进行set-cookie时将上述信息放到cookie中（此时不包含用户名和密码），浏览器拿到cookie后保存（黑客入侵拿到SessionId无法推断用户名密码），在下次请求时放到请求头cookie中（DevTools-Network，对应请求的Headers中包含cookies），如果黑客修改了SessionID，浏览器可以通过签名知道。cookie失效后，浏览器会自动删除该cookie。用户logout时，会话结束，服务器保存的session会清除。</p>\n<p>问题：大量用户同时访问服务器时，产生大量sessionId，</p>\n<ul>\n<li>性能问题</li>\n</ul>\n<p>因为，验证请求是根据sessionid 到数据库中查找session表的，而数据库操作是服务端常见的性能瓶颈，尤其是当用户量比较大的时候。</p>\n<ul>\n<li>扩展性问题</li>\n</ul>\n<p>当系统用户特别多的时候，后端处理请求的服务端通常由多个，部署在多个节点上。 但是多个节点都要访问session表，这样就要求数据库服务能够被多个节点访问，不方便切分数据库以提高性能。</p>\n<p>解决方案：JWT（Json Web Token）</p>\n<h3 id=\"Token\"><a href=\"#Token\" class=\"headerlink\" title=\"Token\"></a>Token</h3><p><img src=\"/2024/07/01/%E4%BA%86%E8%A7%A3cookie-session-token/image-20240701133048798.png\"></p>\n<p>用户登录验证成功后，服务器产生一个JWT返回给浏览器，服务器自身不保存JWT，只保存一个JWT签名的密文，浏览器以cookie或storage的方式存储JWT（<strong>JWT保存在浏览器，服务器保保存一个密钥</strong>secret key）。再次发送请求时附上JWT。</p>\n<p>JWT由 header.payload.signature组成：（token中三个字符串由.分割）</p>\n<ul>\n<li>header：生成签名的算法，一般是哈希算法</li>\n<li>payload：数据，比如有效期</li>\n<li>signature：签名信息，header和payload分别通过base64编码（编码和加密的区别，编码可以解码），服务器保存的密钥secret key和两段编码进行算法运算得到签名信息。</li>\n</ul>\n<p>三部分相关联，修改其中一部分，服务器计算得到的签名就不一致，一定程度上保证安全。Token相当于访问服务器的令牌。</p>\n<p>综上，cookie是一种数据载体。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基础cookie\"><a href=\"#基础cookie\" class=\"headerlink\" title=\"基础cookie\"></a>基础cookie</h3><p>cookie：浏览器给首次服务器发送http请求时进行用户登录验证，用户名密码验证成功，服务器在响应时会set-cookie也就是cookie设置（包含name-value属性，理解为用户名和密码），浏览器收到响应后将cookie保存起来（通过DevTools开发者工具-application-cookie可查看，<strong>保存在浏览器中</strong>），后面浏览器发送的每一个HTTP请求都会附上cookie（作为请求头的一部分）。</p>\n<p>问题：如果把用户名密码存在cookie中，当电脑被黑，会泄露信息很不安全。</p>\n<p>解决方案：在cookie中不存放用户名密码，而是session id</p>\n<h3 id=\"基于cookie的session\"><a href=\"#基于cookie的session\" class=\"headerlink\" title=\"基于cookie的session\"></a>基于cookie的session</h3><p>session：将浏览器访问服务器行为看作会话，用户登录验证通过后，服务器生成新的session对象，包含{SessionId: xxPSnj01(无规律字符串，唯一), Max-Age:会话结束时间对应cookie有效期…}（<strong>保存在服务器自身数据库中</strong>），在响应请求进行set-cookie时将上述信息放到cookie中（此时不包含用户名和密码），浏览器拿到cookie后保存（黑客入侵拿到SessionId无法推断用户名密码），在下次请求时放到请求头cookie中（DevTools-Network，对应请求的Headers中包含cookies），如果黑客修改了SessionID，浏览器可以通过签名知道。cookie失效后，浏览器会自动删除该cookie。用户logout时，会话结束，服务器保存的session会清除。</p>\n<p>问题：大量用户同时访问服务器时，产生大量sessionId，</p>\n<ul>\n<li>性能问题</li>\n</ul>\n<p>因为，验证请求是根据sessionid 到数据库中查找session表的，而数据库操作是服务端常见的性能瓶颈，尤其是当用户量比较大的时候。</p>\n<ul>\n<li>扩展性问题</li>\n</ul>\n<p>当系统用户特别多的时候，后端处理请求的服务端通常由多个，部署在多个节点上。 但是多个节点都要访问session表，这样就要求数据库服务能够被多个节点访问，不方便切分数据库以提高性能。</p>\n<p>解决方案：JWT（Json Web Token）</p>\n<h3 id=\"Token\"><a href=\"#Token\" class=\"headerlink\" title=\"Token\"></a>Token</h3><p><img src=\"/2024/07/01/%E4%BA%86%E8%A7%A3cookie-session-token/image-20240701133048798.png\"></p>\n<p>用户登录验证成功后，服务器产生一个JWT返回给浏览器，服务器自身不保存JWT，只保存一个JWT签名的密文，浏览器以cookie或storage的方式存储JWT（<strong>JWT保存在浏览器，服务器保保存一个密钥</strong>secret key）。再次发送请求时附上JWT。</p>\n<p>JWT由 header.payload.signature组成：（token中三个字符串由.分割）</p>\n<ul>\n<li>header：生成签名的算法，一般是哈希算法</li>\n<li>payload：数据，比如有效期</li>\n<li>signature：签名信息，header和payload分别通过base64编码（编码和加密的区别，编码可以解码），服务器保存的密钥secret key和两段编码进行算法运算得到签名信息。</li>\n</ul>\n<p>三部分相关联，修改其中一部分，服务器计算得到的签名就不一致，一定程度上保证安全。Token相当于访问服务器的令牌。</p>\n<p>综上，cookie是一种数据载体。</p>\n"},{"title":"天气数据下载与解析","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2024-06-10T15:40:47.000Z","password":null,"summary":null,"_content":"\n最近在做一个项目，需要搭建一个天气数据服务，考察了诸多天气网站API之后，综合考量选择了使用Herbie数据库进行天气预测数据的下载，顺手记录一下使用Herbie库、pygrib等库进行数据下载、解析的使用方法。\n# 如何下载\n## Herbie库\n### 简介\n[Herbie](https://herbie.readthedocs.io/en/stable/)是一个Python软件包，通过该库可以使用简单的几行命令下载最新的和历史的数值天气预报（NWP）模型输出，这些数据来源于不同的云存储档案，NWP数据是以GRIB2格式分发的，可以通过xarray（cfgrib）或者pygrib包读取。Herbie库极大地简化了访问和处理复杂NWP模型数据的过程，使得研究人员和开发者能够更高效地探索和使用这些数据。\n### 环境安装和配置\nHerbie库支持Xarray访问数据，依赖python3.9+版本，建议使用conda构建一个python3.9的虚拟环境，安装Anaconda的步骤不再赘述。\n```python\n#构建python3.9虚拟环境， conda版本 4.10.1\nconda create --name <your_virtual_env> python=3.9\nconda env list\nconda activate <your_virtual_env>\nconda install -c conda-forge herbie-data\n```\nHerbie库安装成功后，会生成一个默认的配置文件，位于`~/.config/herbie/config.toml`\n内容如下：\n```toml\n# Herbie defaults\n\n[default]\nmodel = \"hrrr\"   #使用模型\nfxx = 0  #预测时效性\nsave_dir = \"path_to_your_save_dir\"  #下载的grib2文件保存路径\noverwrite = false  #为false表示如果本地已存在模型文件，则不重复下载\nverbose = true  #下载时打印详细信息\n\n# =============================================================================\n# You can set the priority order for checking data sources.\n# If you don't specify a default priority, Herbie will check each source in the\n# order listed in the model template file. Beware: setting a default priority\n# might prevent you from checking all available sources.\n#\n#priority = ['aws', 'nomads', 'google', 'azure', 'etc.']\n```\n\n### 数值天气预报模型\n通过Herbie可以下载来自不同天气预报模型的数据，目前主要使用过其中三种：\n- HRRR高分辨率快速刷新模型：专注于美国本土及其近海区域的短期预报，如果需要全球范围的天气预报数据，就不要考虑该模型了；\n- ECMWF欧洲中期天气预报中心模型：精度高，模型数据文件大（超过1GB），下载较慢，更新时效也慢一些；\n- GFS全球预报系统模型：由美国国家海洋和大气管理局 (NOAA) 运营，是一个全球范围内的天气预报模型，更新较快，下载也快一些。gfs模型下载的文件名格式形如：`gfs.t06z.pgrb2.0p25.f024`\n\t- gfs: 表示这是来自GFS模型的数据。\n\t- .t06z: 表示数据是从UTC（世界协调时间）06:00开始的预报周期。\n\t- .pgrb2: 表示数据是以GRIB2格式编码的。GRIB（GRIdded Binary，网格二进制）是一种广泛使用的气象数据交换格式，GRIB2是其更新版本。\n\t- .0p25: 表示数据的空间分辨率是0.25度经纬度网格，也就是约28公里左右的网格间距。\n\t- .f024: 表示这是从预报周期开始后的第24小时的预报数据。GFS通常会生成长达16天（384小时）的预报。\n\n### 下载最新的数据\nHerbie库在请求天气预报模型数据时，默认使用协调世界时（Coordinated Universal Time, UTC）作为时间标准。Herbie中的天气预报模型包含四个预测周期，UTC时间每日的00:00、6:00、12:00、18:00，换算成北京时间需要加上8个小时。\n下载最新预测天气数据可以使用如下代码，该代码会自动从最近的预测周期开始查找预测数据。\n```python\n#以下载预测时效为24小时的gfs模型数据为例，其他模型注意更换参数\nH = HerbieLatest(model=\"gfs\", product=\"pgrb2.0p25\", fxx=24)\nH.Download(verbose=True)\nprint(H.Date) #获取预测时间\n```\n# 如何解析\n下载天气数据均为[grib2](https://herbie.readthedocs.io/en/stable/user_guide/background/grib2.html)文件，官方给出了两个解析工具——cfgrib和pygrib。安装命令如下：\n```python\nconda install -c conda-forge pygrib cfgrib\n```\n两者都是用于处理GRIB2格式气象数据的Python库，但它们在使用方式、依赖关系和返回数据的形式上有所区别：\n## cfgrib\n- **依赖关系**：`cfgrib`是`xarray`库的一个依赖，用于直接读取GRIB数据到`xarray.Dataset`对象。这意味着它充分利用了`xarray`强大的多维数据处理能力，适合那些熟悉`xarray`或需要进行高级数据分析的用户。\n- **使用方式**：使用`cfgrib`通常通过`xarray.open_dataset()`函数，指定GRIB文件路径或URL，以及引擎为`cfgrib`。例如：\n```python\nimport xarray as xr\nwith xr.open_dataset(grib2_path, engine='cfgrib',\n                     backend_kwargs={'filter_by_keys': {'stepType': 'accum', 'typeOfLevel': 'surface'}}) as ds:\n    # 打印所有变量名称\n    print(\"Variables in the GRIB2 file:\")\n    for var_name in ds.data_vars:\n       print(var_name)\n    # 打印具体变量的数值和经纬度\n    tp = ds['tp'] #tp是变量名，表示总降水量\n    print(tp.shape)\n    print(tp.values)\n    print(tp.latitude.values)\n    print(tp.longitude.values)\n```\n- **返回数据形式**：`cfgrib`返回的是一个`xarray.Dataset`对象，其中包含了多个`xarray.DataArray`。每个`DataArray`对应GRIB文件中的一个变量，包含数据值、坐标（时间和空间维度）以及元数据（如单位、描述等）。这种数据结构非常适合进行数组运算、筛选、切片和复杂的数据分析。\n## [pygrib](https://jswhit.github.io/pygrib/api.html)\n- **依赖关系**：`pygrib`是一个独立的库，直接基于ECMWF的GRIB API，不需要`xarray`作为基础。它主要用于直接读取和操作GRIB2文件中的数据。\n- **使用方式**：使用`pygrib`首先需要打开GRIB文件，然后逐条读取或选择特定的记录。例如：\n```python\nimport pygrib\ngrbs = pygrib.open('path/to/file.grib2')\nfor grb in grbs:\n    print(grb.name, grb.shortName, grb.typeOfLevel, grb.stepType)\n\tdata, lats, lons = grb.data(), grb.latlons()\ngrbs.close()\n```\n- **返回数据形式**：`pygrib`处理单个GRIB记录时，通常会返回数据值（如一个NumPy数组），以及通过单独调用获得的地理坐标信息（如经纬度网格）。这意味着，相比`cfgrib`，它返回的数据形式更基础，需要用户自己处理数据的结构化和后续分析。","source":"_posts/天气数据下载与解析.md","raw":"---\ntitle: 天气数据下载与解析\ntop: false\ncover: false\ntoc: true\nmathjax: true\ntags:\n  - gis\n  - python\ndate: 2024-06-10 23:40:47\npassword:\nsummary:\ncategories:\n---\n\n最近在做一个项目，需要搭建一个天气数据服务，考察了诸多天气网站API之后，综合考量选择了使用Herbie数据库进行天气预测数据的下载，顺手记录一下使用Herbie库、pygrib等库进行数据下载、解析的使用方法。\n# 如何下载\n## Herbie库\n### 简介\n[Herbie](https://herbie.readthedocs.io/en/stable/)是一个Python软件包，通过该库可以使用简单的几行命令下载最新的和历史的数值天气预报（NWP）模型输出，这些数据来源于不同的云存储档案，NWP数据是以GRIB2格式分发的，可以通过xarray（cfgrib）或者pygrib包读取。Herbie库极大地简化了访问和处理复杂NWP模型数据的过程，使得研究人员和开发者能够更高效地探索和使用这些数据。\n### 环境安装和配置\nHerbie库支持Xarray访问数据，依赖python3.9+版本，建议使用conda构建一个python3.9的虚拟环境，安装Anaconda的步骤不再赘述。\n```python\n#构建python3.9虚拟环境， conda版本 4.10.1\nconda create --name <your_virtual_env> python=3.9\nconda env list\nconda activate <your_virtual_env>\nconda install -c conda-forge herbie-data\n```\nHerbie库安装成功后，会生成一个默认的配置文件，位于`~/.config/herbie/config.toml`\n内容如下：\n```toml\n# Herbie defaults\n\n[default]\nmodel = \"hrrr\"   #使用模型\nfxx = 0  #预测时效性\nsave_dir = \"path_to_your_save_dir\"  #下载的grib2文件保存路径\noverwrite = false  #为false表示如果本地已存在模型文件，则不重复下载\nverbose = true  #下载时打印详细信息\n\n# =============================================================================\n# You can set the priority order for checking data sources.\n# If you don't specify a default priority, Herbie will check each source in the\n# order listed in the model template file. Beware: setting a default priority\n# might prevent you from checking all available sources.\n#\n#priority = ['aws', 'nomads', 'google', 'azure', 'etc.']\n```\n\n### 数值天气预报模型\n通过Herbie可以下载来自不同天气预报模型的数据，目前主要使用过其中三种：\n- HRRR高分辨率快速刷新模型：专注于美国本土及其近海区域的短期预报，如果需要全球范围的天气预报数据，就不要考虑该模型了；\n- ECMWF欧洲中期天气预报中心模型：精度高，模型数据文件大（超过1GB），下载较慢，更新时效也慢一些；\n- GFS全球预报系统模型：由美国国家海洋和大气管理局 (NOAA) 运营，是一个全球范围内的天气预报模型，更新较快，下载也快一些。gfs模型下载的文件名格式形如：`gfs.t06z.pgrb2.0p25.f024`\n\t- gfs: 表示这是来自GFS模型的数据。\n\t- .t06z: 表示数据是从UTC（世界协调时间）06:00开始的预报周期。\n\t- .pgrb2: 表示数据是以GRIB2格式编码的。GRIB（GRIdded Binary，网格二进制）是一种广泛使用的气象数据交换格式，GRIB2是其更新版本。\n\t- .0p25: 表示数据的空间分辨率是0.25度经纬度网格，也就是约28公里左右的网格间距。\n\t- .f024: 表示这是从预报周期开始后的第24小时的预报数据。GFS通常会生成长达16天（384小时）的预报。\n\n### 下载最新的数据\nHerbie库在请求天气预报模型数据时，默认使用协调世界时（Coordinated Universal Time, UTC）作为时间标准。Herbie中的天气预报模型包含四个预测周期，UTC时间每日的00:00、6:00、12:00、18:00，换算成北京时间需要加上8个小时。\n下载最新预测天气数据可以使用如下代码，该代码会自动从最近的预测周期开始查找预测数据。\n```python\n#以下载预测时效为24小时的gfs模型数据为例，其他模型注意更换参数\nH = HerbieLatest(model=\"gfs\", product=\"pgrb2.0p25\", fxx=24)\nH.Download(verbose=True)\nprint(H.Date) #获取预测时间\n```\n# 如何解析\n下载天气数据均为[grib2](https://herbie.readthedocs.io/en/stable/user_guide/background/grib2.html)文件，官方给出了两个解析工具——cfgrib和pygrib。安装命令如下：\n```python\nconda install -c conda-forge pygrib cfgrib\n```\n两者都是用于处理GRIB2格式气象数据的Python库，但它们在使用方式、依赖关系和返回数据的形式上有所区别：\n## cfgrib\n- **依赖关系**：`cfgrib`是`xarray`库的一个依赖，用于直接读取GRIB数据到`xarray.Dataset`对象。这意味着它充分利用了`xarray`强大的多维数据处理能力，适合那些熟悉`xarray`或需要进行高级数据分析的用户。\n- **使用方式**：使用`cfgrib`通常通过`xarray.open_dataset()`函数，指定GRIB文件路径或URL，以及引擎为`cfgrib`。例如：\n```python\nimport xarray as xr\nwith xr.open_dataset(grib2_path, engine='cfgrib',\n                     backend_kwargs={'filter_by_keys': {'stepType': 'accum', 'typeOfLevel': 'surface'}}) as ds:\n    # 打印所有变量名称\n    print(\"Variables in the GRIB2 file:\")\n    for var_name in ds.data_vars:\n       print(var_name)\n    # 打印具体变量的数值和经纬度\n    tp = ds['tp'] #tp是变量名，表示总降水量\n    print(tp.shape)\n    print(tp.values)\n    print(tp.latitude.values)\n    print(tp.longitude.values)\n```\n- **返回数据形式**：`cfgrib`返回的是一个`xarray.Dataset`对象，其中包含了多个`xarray.DataArray`。每个`DataArray`对应GRIB文件中的一个变量，包含数据值、坐标（时间和空间维度）以及元数据（如单位、描述等）。这种数据结构非常适合进行数组运算、筛选、切片和复杂的数据分析。\n## [pygrib](https://jswhit.github.io/pygrib/api.html)\n- **依赖关系**：`pygrib`是一个独立的库，直接基于ECMWF的GRIB API，不需要`xarray`作为基础。它主要用于直接读取和操作GRIB2文件中的数据。\n- **使用方式**：使用`pygrib`首先需要打开GRIB文件，然后逐条读取或选择特定的记录。例如：\n```python\nimport pygrib\ngrbs = pygrib.open('path/to/file.grib2')\nfor grb in grbs:\n    print(grb.name, grb.shortName, grb.typeOfLevel, grb.stepType)\n\tdata, lats, lons = grb.data(), grb.latlons()\ngrbs.close()\n```\n- **返回数据形式**：`pygrib`处理单个GRIB记录时，通常会返回数据值（如一个NumPy数组），以及通过单独调用获得的地理坐标信息（如经纬度网格）。这意味着，相比`cfgrib`，它返回的数据形式更基础，需要用户自己处理数据的结构化和后续分析。","slug":"天气数据下载与解析","published":1,"updated":"2024-06-11T10:55:41.507Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly2zhjn4000exdqr3j6t006e","content":"<p>最近在做一个项目，需要搭建一个天气数据服务，考察了诸多天气网站API之后，综合考量选择了使用Herbie数据库进行天气预测数据的下载，顺手记录一下使用Herbie库、pygrib等库进行数据下载、解析的使用方法。</p>\n<h1 id=\"如何下载\"><a href=\"#如何下载\" class=\"headerlink\" title=\"如何下载\"></a>如何下载</h1><h2 id=\"Herbie库\"><a href=\"#Herbie库\" class=\"headerlink\" title=\"Herbie库\"></a>Herbie库</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p><a href=\"https://herbie.readthedocs.io/en/stable/\">Herbie</a>是一个Python软件包，通过该库可以使用简单的几行命令下载最新的和历史的数值天气预报（NWP）模型输出，这些数据来源于不同的云存储档案，NWP数据是以GRIB2格式分发的，可以通过xarray（cfgrib）或者pygrib包读取。Herbie库极大地简化了访问和处理复杂NWP模型数据的过程，使得研究人员和开发者能够更高效地探索和使用这些数据。</p>\n<h3 id=\"环境安装和配置\"><a href=\"#环境安装和配置\" class=\"headerlink\" title=\"环境安装和配置\"></a>环境安装和配置</h3><p>Herbie库支持Xarray访问数据，依赖python3.9+版本，建议使用conda构建一个python3.9的虚拟环境，安装Anaconda的步骤不再赘述。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\">#构建python3.9虚拟环境， conda版本 4.10.1</span><br>conda create --name &lt;your_virtual_env&gt; python=<span class=\"hljs-number\">3.9</span><br>conda env <span class=\"hljs-built_in\">list</span><br>conda activate &lt;your_virtual_env&gt;<br>conda install -c conda-forge herbie-data<br></code></pre></td></tr></table></figure>\n<p>Herbie库安装成功后，会生成一个默认的配置文件，位于<code>~/.config/herbie/config.toml</code><br>内容如下：</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs toml\"><span class=\"hljs-comment\"># Herbie defaults</span><br><br><span class=\"hljs-section\">[default]</span><br><span class=\"hljs-attr\">model</span> = <span class=\"hljs-string\">&quot;hrrr&quot;</span>   <span class=\"hljs-comment\">#使用模型</span><br><span class=\"hljs-attr\">fxx</span> = <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">#预测时效性</span><br><span class=\"hljs-attr\">save_dir</span> = <span class=\"hljs-string\">&quot;path_to_your_save_dir&quot;</span>  <span class=\"hljs-comment\">#下载的grib2文件保存路径</span><br><span class=\"hljs-attr\">overwrite</span> = <span class=\"hljs-literal\">false</span>  <span class=\"hljs-comment\">#为false表示如果本地已存在模型文件，则不重复下载</span><br><span class=\"hljs-attr\">verbose</span> = <span class=\"hljs-literal\">true</span>  <span class=\"hljs-comment\">#下载时打印详细信息</span><br><br><span class=\"hljs-comment\"># =============================================================================</span><br><span class=\"hljs-comment\"># You can set the priority order for checking data sources.</span><br><span class=\"hljs-comment\"># If you don&#x27;t specify a default priority, Herbie will check each source in the</span><br><span class=\"hljs-comment\"># order listed in the model template file. Beware: setting a default priority</span><br><span class=\"hljs-comment\"># might prevent you from checking all available sources.</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\">#priority = [&#x27;aws&#x27;, &#x27;nomads&#x27;, &#x27;google&#x27;, &#x27;azure&#x27;, &#x27;etc.&#x27;]</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"数值天气预报模型\"><a href=\"#数值天气预报模型\" class=\"headerlink\" title=\"数值天气预报模型\"></a>数值天气预报模型</h3><p>通过Herbie可以下载来自不同天气预报模型的数据，目前主要使用过其中三种：</p>\n<ul>\n<li>HRRR高分辨率快速刷新模型：专注于美国本土及其近海区域的短期预报，如果需要全球范围的天气预报数据，就不要考虑该模型了；</li>\n<li>ECMWF欧洲中期天气预报中心模型：精度高，模型数据文件大（超过1GB），下载较慢，更新时效也慢一些；</li>\n<li>GFS全球预报系统模型：由美国国家海洋和大气管理局 (NOAA) 运营，是一个全球范围内的天气预报模型，更新较快，下载也快一些。gfs模型下载的文件名格式形如：<code>gfs.t06z.pgrb2.0p25.f024</code><ul>\n<li>gfs: 表示这是来自GFS模型的数据。</li>\n<li>.t06z: 表示数据是从UTC（世界协调时间）06:00开始的预报周期。</li>\n<li>.pgrb2: 表示数据是以GRIB2格式编码的。GRIB（GRIdded Binary，网格二进制）是一种广泛使用的气象数据交换格式，GRIB2是其更新版本。</li>\n<li>.0p25: 表示数据的空间分辨率是0.25度经纬度网格，也就是约28公里左右的网格间距。</li>\n<li>.f024: 表示这是从预报周期开始后的第24小时的预报数据。GFS通常会生成长达16天（384小时）的预报。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"下载最新的数据\"><a href=\"#下载最新的数据\" class=\"headerlink\" title=\"下载最新的数据\"></a>下载最新的数据</h3><p>Herbie库在请求天气预报模型数据时，默认使用协调世界时（Coordinated Universal Time, UTC）作为时间标准。Herbie中的天气预报模型包含四个预测周期，UTC时间每日的00:00、6:00、12:00、18:00，换算成北京时间需要加上8个小时。<br>下载最新预测天气数据可以使用如下代码，该代码会自动从最近的预测周期开始查找预测数据。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\">#以下载预测时效为24小时的gfs模型数据为例，其他模型注意更换参数</span><br>H = HerbieLatest(model=<span class=\"hljs-string\">&quot;gfs&quot;</span>, product=<span class=\"hljs-string\">&quot;pgrb2.0p25&quot;</span>, fxx=<span class=\"hljs-number\">24</span>)<br>H.Download(verbose=<span class=\"hljs-literal\">True</span>)<br><span class=\"hljs-built_in\">print</span>(H.Date) <span class=\"hljs-comment\">#获取预测时间</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"如何解析\"><a href=\"#如何解析\" class=\"headerlink\" title=\"如何解析\"></a>如何解析</h1><p>下载天气数据均为<a href=\"https://herbie.readthedocs.io/en/stable/user_guide/background/grib2.html\">grib2</a>文件，官方给出了两个解析工具——cfgrib和pygrib。安装命令如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">conda install -c conda-forge pygrib cfgrib<br></code></pre></td></tr></table></figure>\n<p>两者都是用于处理GRIB2格式气象数据的Python库，但它们在使用方式、依赖关系和返回数据的形式上有所区别：</p>\n<h2 id=\"cfgrib\"><a href=\"#cfgrib\" class=\"headerlink\" title=\"cfgrib\"></a>cfgrib</h2><ul>\n<li><strong>依赖关系</strong>：<code>cfgrib</code>是<code>xarray</code>库的一个依赖，用于直接读取GRIB数据到<code>xarray.Dataset</code>对象。这意味着它充分利用了<code>xarray</code>强大的多维数据处理能力，适合那些熟悉<code>xarray</code>或需要进行高级数据分析的用户。</li>\n<li><strong>使用方式</strong>：使用<code>cfgrib</code>通常通过<code>xarray.open_dataset()</code>函数，指定GRIB文件路径或URL，以及引擎为<code>cfgrib</code>。例如：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> xarray <span class=\"hljs-keyword\">as</span> xr<br><span class=\"hljs-keyword\">with</span> xr.open_dataset(grib2_path, engine=<span class=\"hljs-string\">&#x27;cfgrib&#x27;</span>,<br>                     backend_kwargs=&#123;<span class=\"hljs-string\">&#x27;filter_by_keys&#x27;</span>: &#123;<span class=\"hljs-string\">&#x27;stepType&#x27;</span>: <span class=\"hljs-string\">&#x27;accum&#x27;</span>, <span class=\"hljs-string\">&#x27;typeOfLevel&#x27;</span>: <span class=\"hljs-string\">&#x27;surface&#x27;</span>&#125;&#125;) <span class=\"hljs-keyword\">as</span> ds:<br>    <span class=\"hljs-comment\"># 打印所有变量名称</span><br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Variables in the GRIB2 file:&quot;</span>)<br>    <span class=\"hljs-keyword\">for</span> var_name <span class=\"hljs-keyword\">in</span> ds.data_vars:<br>       <span class=\"hljs-built_in\">print</span>(var_name)<br>    <span class=\"hljs-comment\"># 打印具体变量的数值和经纬度</span><br>    tp = ds[<span class=\"hljs-string\">&#x27;tp&#x27;</span>] <span class=\"hljs-comment\">#tp是变量名，表示总降水量</span><br>    <span class=\"hljs-built_in\">print</span>(tp.shape)<br>    <span class=\"hljs-built_in\">print</span>(tp.values)<br>    <span class=\"hljs-built_in\">print</span>(tp.latitude.values)<br>    <span class=\"hljs-built_in\">print</span>(tp.longitude.values)<br></code></pre></td></tr></table></figure></li>\n<li><strong>返回数据形式</strong>：<code>cfgrib</code>返回的是一个<code>xarray.Dataset</code>对象，其中包含了多个<code>xarray.DataArray</code>。每个<code>DataArray</code>对应GRIB文件中的一个变量，包含数据值、坐标（时间和空间维度）以及元数据（如单位、描述等）。这种数据结构非常适合进行数组运算、筛选、切片和复杂的数据分析。</li>\n</ul>\n<h2 id=\"pygrib\"><a href=\"#pygrib\" class=\"headerlink\" title=\"pygrib\"></a><a href=\"https://jswhit.github.io/pygrib/api.html\">pygrib</a></h2><ul>\n<li><strong>依赖关系</strong>：<code>pygrib</code>是一个独立的库，直接基于ECMWF的GRIB API，不需要<code>xarray</code>作为基础。它主要用于直接读取和操作GRIB2文件中的数据。</li>\n<li><strong>使用方式</strong>：使用<code>pygrib</code>首先需要打开GRIB文件，然后逐条读取或选择特定的记录。例如：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pygrib<br>grbs = pygrib.<span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">&#x27;path/to/file.grib2&#x27;</span>)<br><span class=\"hljs-keyword\">for</span> grb <span class=\"hljs-keyword\">in</span> grbs:<br>    <span class=\"hljs-built_in\">print</span>(grb.name, grb.shortName, grb.typeOfLevel, grb.stepType)<br>\tdata, lats, lons = grb.data(), grb.latlons()<br>grbs.close()<br></code></pre></td></tr></table></figure></li>\n<li><strong>返回数据形式</strong>：<code>pygrib</code>处理单个GRIB记录时，通常会返回数据值（如一个NumPy数组），以及通过单独调用获得的地理坐标信息（如经纬度网格）。这意味着，相比<code>cfgrib</code>，它返回的数据形式更基础，需要用户自己处理数据的结构化和后续分析。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在做一个项目，需要搭建一个天气数据服务，考察了诸多天气网站API之后，综合考量选择了使用Herbie数据库进行天气预测数据的下载，顺手记录一下使用Herbie库、pygrib等库进行数据下载、解析的使用方法。</p>\n<h1 id=\"如何下载\"><a href=\"#如何下载\" class=\"headerlink\" title=\"如何下载\"></a>如何下载</h1><h2 id=\"Herbie库\"><a href=\"#Herbie库\" class=\"headerlink\" title=\"Herbie库\"></a>Herbie库</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p><a href=\"https://herbie.readthedocs.io/en/stable/\">Herbie</a>是一个Python软件包，通过该库可以使用简单的几行命令下载最新的和历史的数值天气预报（NWP）模型输出，这些数据来源于不同的云存储档案，NWP数据是以GRIB2格式分发的，可以通过xarray（cfgrib）或者pygrib包读取。Herbie库极大地简化了访问和处理复杂NWP模型数据的过程，使得研究人员和开发者能够更高效地探索和使用这些数据。</p>\n<h3 id=\"环境安装和配置\"><a href=\"#环境安装和配置\" class=\"headerlink\" title=\"环境安装和配置\"></a>环境安装和配置</h3><p>Herbie库支持Xarray访问数据，依赖python3.9+版本，建议使用conda构建一个python3.9的虚拟环境，安装Anaconda的步骤不再赘述。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\">#构建python3.9虚拟环境， conda版本 4.10.1</span><br>conda create --name &lt;your_virtual_env&gt; python=<span class=\"hljs-number\">3.9</span><br>conda env <span class=\"hljs-built_in\">list</span><br>conda activate &lt;your_virtual_env&gt;<br>conda install -c conda-forge herbie-data<br></code></pre></td></tr></table></figure>\n<p>Herbie库安装成功后，会生成一个默认的配置文件，位于<code>~/.config/herbie/config.toml</code><br>内容如下：</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs toml\"><span class=\"hljs-comment\"># Herbie defaults</span><br><br><span class=\"hljs-section\">[default]</span><br><span class=\"hljs-attr\">model</span> = <span class=\"hljs-string\">&quot;hrrr&quot;</span>   <span class=\"hljs-comment\">#使用模型</span><br><span class=\"hljs-attr\">fxx</span> = <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">#预测时效性</span><br><span class=\"hljs-attr\">save_dir</span> = <span class=\"hljs-string\">&quot;path_to_your_save_dir&quot;</span>  <span class=\"hljs-comment\">#下载的grib2文件保存路径</span><br><span class=\"hljs-attr\">overwrite</span> = <span class=\"hljs-literal\">false</span>  <span class=\"hljs-comment\">#为false表示如果本地已存在模型文件，则不重复下载</span><br><span class=\"hljs-attr\">verbose</span> = <span class=\"hljs-literal\">true</span>  <span class=\"hljs-comment\">#下载时打印详细信息</span><br><br><span class=\"hljs-comment\"># =============================================================================</span><br><span class=\"hljs-comment\"># You can set the priority order for checking data sources.</span><br><span class=\"hljs-comment\"># If you don&#x27;t specify a default priority, Herbie will check each source in the</span><br><span class=\"hljs-comment\"># order listed in the model template file. Beware: setting a default priority</span><br><span class=\"hljs-comment\"># might prevent you from checking all available sources.</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\">#priority = [&#x27;aws&#x27;, &#x27;nomads&#x27;, &#x27;google&#x27;, &#x27;azure&#x27;, &#x27;etc.&#x27;]</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"数值天气预报模型\"><a href=\"#数值天气预报模型\" class=\"headerlink\" title=\"数值天气预报模型\"></a>数值天气预报模型</h3><p>通过Herbie可以下载来自不同天气预报模型的数据，目前主要使用过其中三种：</p>\n<ul>\n<li>HRRR高分辨率快速刷新模型：专注于美国本土及其近海区域的短期预报，如果需要全球范围的天气预报数据，就不要考虑该模型了；</li>\n<li>ECMWF欧洲中期天气预报中心模型：精度高，模型数据文件大（超过1GB），下载较慢，更新时效也慢一些；</li>\n<li>GFS全球预报系统模型：由美国国家海洋和大气管理局 (NOAA) 运营，是一个全球范围内的天气预报模型，更新较快，下载也快一些。gfs模型下载的文件名格式形如：<code>gfs.t06z.pgrb2.0p25.f024</code><ul>\n<li>gfs: 表示这是来自GFS模型的数据。</li>\n<li>.t06z: 表示数据是从UTC（世界协调时间）06:00开始的预报周期。</li>\n<li>.pgrb2: 表示数据是以GRIB2格式编码的。GRIB（GRIdded Binary，网格二进制）是一种广泛使用的气象数据交换格式，GRIB2是其更新版本。</li>\n<li>.0p25: 表示数据的空间分辨率是0.25度经纬度网格，也就是约28公里左右的网格间距。</li>\n<li>.f024: 表示这是从预报周期开始后的第24小时的预报数据。GFS通常会生成长达16天（384小时）的预报。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"下载最新的数据\"><a href=\"#下载最新的数据\" class=\"headerlink\" title=\"下载最新的数据\"></a>下载最新的数据</h3><p>Herbie库在请求天气预报模型数据时，默认使用协调世界时（Coordinated Universal Time, UTC）作为时间标准。Herbie中的天气预报模型包含四个预测周期，UTC时间每日的00:00、6:00、12:00、18:00，换算成北京时间需要加上8个小时。<br>下载最新预测天气数据可以使用如下代码，该代码会自动从最近的预测周期开始查找预测数据。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\">#以下载预测时效为24小时的gfs模型数据为例，其他模型注意更换参数</span><br>H = HerbieLatest(model=<span class=\"hljs-string\">&quot;gfs&quot;</span>, product=<span class=\"hljs-string\">&quot;pgrb2.0p25&quot;</span>, fxx=<span class=\"hljs-number\">24</span>)<br>H.Download(verbose=<span class=\"hljs-literal\">True</span>)<br><span class=\"hljs-built_in\">print</span>(H.Date) <span class=\"hljs-comment\">#获取预测时间</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"如何解析\"><a href=\"#如何解析\" class=\"headerlink\" title=\"如何解析\"></a>如何解析</h1><p>下载天气数据均为<a href=\"https://herbie.readthedocs.io/en/stable/user_guide/background/grib2.html\">grib2</a>文件，官方给出了两个解析工具——cfgrib和pygrib。安装命令如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">conda install -c conda-forge pygrib cfgrib<br></code></pre></td></tr></table></figure>\n<p>两者都是用于处理GRIB2格式气象数据的Python库，但它们在使用方式、依赖关系和返回数据的形式上有所区别：</p>\n<h2 id=\"cfgrib\"><a href=\"#cfgrib\" class=\"headerlink\" title=\"cfgrib\"></a>cfgrib</h2><ul>\n<li><strong>依赖关系</strong>：<code>cfgrib</code>是<code>xarray</code>库的一个依赖，用于直接读取GRIB数据到<code>xarray.Dataset</code>对象。这意味着它充分利用了<code>xarray</code>强大的多维数据处理能力，适合那些熟悉<code>xarray</code>或需要进行高级数据分析的用户。</li>\n<li><strong>使用方式</strong>：使用<code>cfgrib</code>通常通过<code>xarray.open_dataset()</code>函数，指定GRIB文件路径或URL，以及引擎为<code>cfgrib</code>。例如：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> xarray <span class=\"hljs-keyword\">as</span> xr<br><span class=\"hljs-keyword\">with</span> xr.open_dataset(grib2_path, engine=<span class=\"hljs-string\">&#x27;cfgrib&#x27;</span>,<br>                     backend_kwargs=&#123;<span class=\"hljs-string\">&#x27;filter_by_keys&#x27;</span>: &#123;<span class=\"hljs-string\">&#x27;stepType&#x27;</span>: <span class=\"hljs-string\">&#x27;accum&#x27;</span>, <span class=\"hljs-string\">&#x27;typeOfLevel&#x27;</span>: <span class=\"hljs-string\">&#x27;surface&#x27;</span>&#125;&#125;) <span class=\"hljs-keyword\">as</span> ds:<br>    <span class=\"hljs-comment\"># 打印所有变量名称</span><br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Variables in the GRIB2 file:&quot;</span>)<br>    <span class=\"hljs-keyword\">for</span> var_name <span class=\"hljs-keyword\">in</span> ds.data_vars:<br>       <span class=\"hljs-built_in\">print</span>(var_name)<br>    <span class=\"hljs-comment\"># 打印具体变量的数值和经纬度</span><br>    tp = ds[<span class=\"hljs-string\">&#x27;tp&#x27;</span>] <span class=\"hljs-comment\">#tp是变量名，表示总降水量</span><br>    <span class=\"hljs-built_in\">print</span>(tp.shape)<br>    <span class=\"hljs-built_in\">print</span>(tp.values)<br>    <span class=\"hljs-built_in\">print</span>(tp.latitude.values)<br>    <span class=\"hljs-built_in\">print</span>(tp.longitude.values)<br></code></pre></td></tr></table></figure></li>\n<li><strong>返回数据形式</strong>：<code>cfgrib</code>返回的是一个<code>xarray.Dataset</code>对象，其中包含了多个<code>xarray.DataArray</code>。每个<code>DataArray</code>对应GRIB文件中的一个变量，包含数据值、坐标（时间和空间维度）以及元数据（如单位、描述等）。这种数据结构非常适合进行数组运算、筛选、切片和复杂的数据分析。</li>\n</ul>\n<h2 id=\"pygrib\"><a href=\"#pygrib\" class=\"headerlink\" title=\"pygrib\"></a><a href=\"https://jswhit.github.io/pygrib/api.html\">pygrib</a></h2><ul>\n<li><strong>依赖关系</strong>：<code>pygrib</code>是一个独立的库，直接基于ECMWF的GRIB API，不需要<code>xarray</code>作为基础。它主要用于直接读取和操作GRIB2文件中的数据。</li>\n<li><strong>使用方式</strong>：使用<code>pygrib</code>首先需要打开GRIB文件，然后逐条读取或选择特定的记录。例如：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pygrib<br>grbs = pygrib.<span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">&#x27;path/to/file.grib2&#x27;</span>)<br><span class=\"hljs-keyword\">for</span> grb <span class=\"hljs-keyword\">in</span> grbs:<br>    <span class=\"hljs-built_in\">print</span>(grb.name, grb.shortName, grb.typeOfLevel, grb.stepType)<br>\tdata, lats, lons = grb.data(), grb.latlons()<br>grbs.close()<br></code></pre></td></tr></table></figure></li>\n<li><strong>返回数据形式</strong>：<code>pygrib</code>处理单个GRIB记录时，通常会返回数据值（如一个NumPy数组），以及通过单独调用获得的地理坐标信息（如经纬度网格）。这意味着，相比<code>cfgrib</code>，它返回的数据形式更基础，需要用户自己处理数据的结构化和后续分析。</li>\n</ul>\n"},{"title":"快速搭建个人博客网站","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2024-06-18T04:53:07.000Z","password":null,"summary":null,"_content":"\n# 背景需求\n\n一直在寻找一个合适的平台记录自己的学习笔记、技术开发经验以及日常阅读写作等，尝试了诸多方案，笔记软件类的印象笔记、飞书、Notion、wolai、flomo、obsidian，总觉得少些什么，在封闭的软件中似乎少了一些输出端的监督，后搬运了几篇文章到公众号，但是修改有限制，且引用外部链接不方便。于是乎决定干脆自己搭一个博客网站，考察了很多方案，也参考了很多教程经验，最终选用github+hexo+obdian的框架，主要是因为这三个工具都有一定的使用基础，在学习前端的过程中逐渐熟悉了nodejs，git也是长期在用的版本管理工具，再加上之前也使用了很长一段时间的obsidian做知识管理，有了以上的基础后，便将这个搭建网站这个想法付诸实践。本篇文章主要记录个人搭建博客网站的步骤和参考的教程。\n目前因为经济方面的原因，没有购买域名，暂时借助github pages实现免费托管。\n\n# 安装配置\n网站框架依赖的工具包括hexo、github、obsidian，下面依次介绍这三者的安装配置过程。\n涉及到终端、yml等配置文件的编辑时使用的工具为[vscode](https://code.visualstudio.com/)，也可以使用电脑自带的终端/命令行工具和编辑器。\n## Hexo\n[hexo](https://hexo.io/zh-cn/docs/one-command-deployment)是基于Node.js编写的静态网站生成器，在发布和部署网页时需要用到git分布式管理工具，因此我们需要先安装两个依赖：\n- git\n- Node.js\n### git安装\n到[git官网](https://git-scm.com/download/)下载对应系统版本的安装包或根据官网指引安装。安装完成后在终端输入`git -v`，如果能正确显示git版本说明安装成功。\n### Node.js安装\n首先安装Node.js，到[Node.js官网](https://nodejs.cn/download/)选择下载系统适用的版本，按照安装程序指引一步步安装即可。\n![](image-20240618193622234.png)\n\n安装完成后，在终端中依次输入：\n```bash\nnode -v\nnpm -v\n```\n如果显示node和npm版本，说明正确安装。在安装Node时，会同时安装npm，npm是node的包管理工具。我这里安装的node版本是`v20.13.1`，npm版本是v10.5.2。\n\n![](image-20240618194011460.png)\n### Hexo安装\n使用npm包管理工具安装Hexo，由于npm仓库服务器在国外，下载速度较慢，先修改npm的镜像源为阿里镜像：\n```bash\nnpm config set registry https://registry.npm.taobao.org\n```\n\nnpm有多个安装选项：\n>-S/--save 局部安装，发布到生产环境，写入到package.json文件中的dependencie里\n>-D/--save-dev 局部安装，发布到开发环境， 写入到package.json文件中的devDependencies 里\n>-g 全局安装，安装一次，其他地方也能使用\n\n我们全局安装Hexo\n```bash\nnpm install hexo-cli -g\nhexo -v #打印hexo版本说明安装成功\n```\n![](image-20240618204259093.png)\n\n在本地创建一个文件夹，用于存放你的博客站点文章和配置文件，比如`my-blog`。打开终端输入：\n```bash\nmkdir my-blog && cd my-blog\n#初始化文件夹\nhexo init\n#安装必备的组件\nnpm install\n#生成静态网页\nhexo g\n#打开本地服务器\nhexo s\n```\n执行上述命令后，打开`localhost:8000`即可看到原始的博客网站效果，只有一个Hellow world页面。\n\n## git+github配置\n### git连接配置\n在上一节中，我们安装了git工具，由于我们的网站是借助`Github Pages`托管，所以先去[github](https://github.com/)上注册一个账号，然后连接本地git仓库和远程github仓库，打开终端输入（windows用户打开git bash进行输入）：\n```bash\ngit config --global user.name \"yourname\" #修改为你的github账号名\ngit config --global user.email \"youremail\" #修改为你的github账号邮箱\n```\n配置完成后，可使用如下命令验证能否登录github：\n```bash\nssh -T git@github.com\n```\n按照提示输入用户名和密码后，如果出现以下内容，说明连接成功。\n![](image-20240618210158068.png)\n\n\n在本地生成SSH密钥，用于向远程仓库推送内容。\n```bash\nssh-keygen -t rsa -C \"youremail\"\n\n#生成之后复制SSH公钥\ncat ~/.ssh/id_rsa.pub\n```\n登录github，点击头像-settings，粘贴公钥\n![](image-20240618211935184.png)\n如果github无法登录或访问速度太慢，可参考这篇帖子[如何解决mac无法访问github_mac打不开github-CSDN博客](https://blog.csdn.net/elena_705/article/details/135172231)\n### 新建github.io仓库\n接下来我们新建一个github仓库，点击+号新建仓库。\n![](image-20240618212022198.png)\n注意仓库的名字前缀一定要和你的账户名相同，后缀就是github.io。\n![](image-20240618212413299.png)\n创建完成后，进入仓库，点击settings-pages\n![](image-20240618212456346.png)\n\n![](image-20240618212640334.png)\n使用默认的Branch配置，可以看到对应的`github pages`地址，比如我的是`https://lexieisfree.github.io`。\n\n### 安装`hexo-deployer-git`插件\n安装该插件后我们可以将博客网页内容托管到`Github pages`，就不用时刻在本地运行服务器啦。\n我们在上文创建的博客文件夹（比如我是my-blog）下使用生产环境安装`hexo-deployer-git`插件：\n```bash\nnpm install --save `hexo-deployer-git`\n```\n打开`_config.yml`配置文件添加如下内容：\n```yml\ndeploy: type: git repo: git@github.com:lexieisfree/lexieisfree.github.io.git #修改为你的git仓库地址\nbranch: main   \n```\n\n注意，deploy配置仓库地址一定要用git地址(ssh连接地址), github 2021年8月之后就不支持http密码验证登录。\n\n配置完成后，我们在my-blog（你的博客文件夹下）使用终端运行：\n```bash\nhexo d\n```\n即可将内容部署到github.io仓库中。\n## Fluid主题配置\n我的博客站点使用[fluid](https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97)主题，在生产环境安装`hexo-theme-fluid`\n```bash\nnpm install --save hexo-theme-fluid\n```\n\nHexo 5.0.0 版本以上的用户，在博客目录下创建 `_config.fluid.yml` 文件，将主题配置文件`_config.yml`的全部配置（或部分配置）复制过去。\n\n基本配置可参考：[开始使用 | Hexo Fluid 用户手册 (fluid-dev.com)](https://hexo.fluid-dev.com/docs/start/#%E4%B8%BB%E9%A2%98%E7%AE%80%E4%BB%8B)\n\n- 在`_config.yml`中指定主题\n```yml\ntheme: fluid\n```\n\n- 添加「关于页」\n```bash\n#终端输入\nhexo new page about\n```\n创建成功后修改 `/source/about/index.md`，添加 `layout` 属性。\n\n修改后的文件示例如下：\n\n```\n---\ntitle: 标题\nlayout: about\n---\n\n这里写关于页的正文，支持 Markdown, HTML\n```\n\n- 配置标题（在`_config.fluid.yml`中修改对应内容）\n```yml\n# Site\ntitle: 修改为你的博客标题\nsubtitle: ''\ndescription: ''\nkeywords:\nauthor: 修改为你的名字\nlanguage: zh-CN\ntimezone: ''\n\nnavbar:\n\tblog_title: 修改为你的博客标题\n```\n- 给自己加个slogan\n```yml\nindex:\n\tslogan:\n\t\tenable: true\n\t\ttext: 修改为你的slogan\n\t\tapi:\n\t\tenable: false\n\t\turl: \"https://v1.hitokoto.cn/\"\n\t\tmethod: \"GET\"\n\t\theaders: {}\n\t\tkeys: [\"hitokoto\"]\n```\n\n其他的个性化配置可以参考[fluid官方文档](https://hexo.fluid-dev.com/docs/guide/)\n\n## obsidian配置\n其实这一步不是必要的，只是我个人喜欢用obsidian编辑markdown文档，如果你也想用obsidian编辑你的博客文章可以参考。\nobsidian安装包[下载](https://thoughts.teambition.com/share/62a131711a6baa00416a79d3#title=Obsidian_%E5%AE%89%E8%A3%85%E5%8C%85)\nobsidian的基础用法不再过多赘述，具体可以参考这篇帖子：[PKMer_Obsidian](https://pkmer.cn/Pkmer-Docs/10-obsidian/obsidian/)\n\n在Hexo安装一节中我们创建了一个博客目录my-blog，该目录包含如下文件：\n![](image-20240618223842003.png)\n其中，source文件夹在存放了发布的文章（_posts）和草稿(_drafts)，scaffolds存放模板文件。\n我们使用obsidian打开my-blog/source文件夹。\n\n\n在使用obsidian之前，先安装必要的插件：\n- `PKMer`主要是为了后续安装插件更方便：[PKMer_PKMer 插件主题市场](https://pkmer.cn/products/market/)\n- `custom Attachment Location`： 使用该插件可以在粘贴图片到文章时自动修改图片的存放位置，比如文章的同名文件夹下。\n![](image-20240618222851091.png)\n\n`custom Attachment Location`插件配置：\n\n![](image-20240618223151710.png)\n\n\n# 发布文章\n接下来，就可以愉快地写文章发布啦。\nhexo的使用可参考官方文档：[指令 | Hexo](https://hexo.io/zh-cn/docs/commands)\n\n### 创建博客文章\n终端在博客目录下输入命令：\n```bash\n#创建新博客，执行完成后会在source/_posts文件夹下生成对应的md文档和同名目录\nhexo new post 文章标题  \n\n#创建博客草稿\nhexo new draft 草稿标题\n#草稿发布\nhexo publish 草稿标题\n```\n用obsdian打开source文件夹，编辑文章。\n\n## 生成发布文章\n```bash\nhexo clean #清除缓存\nhexo generate 或 hexo g #生成静态文件\nhexo server 或hexo s #本地运行服务器预览网页\nhexo deploy 或hexo d #静态文件上传到远程服务器\n```\n## 删除文章\n在`my-blog/source/_posts`直接删除文章和对应文件夹（可在obsidian中直接删除）。\n\n重新执行如下命令：\n\n```Bash\nhexo clean\nhexo g\nhexo d  \n```\n# 参考资料\n- [关于我使用obsidian加hexo部署个人博客的过程 - SagiRastar's Blog (sagi-rastar.github.io)](https://sagi-rastar.github.io/2023/11/10/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BD%BF%E7%94%A8obsidian%E5%8A%A0hexo%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B/)\n- [超详细Hexo+Github博客搭建小白教程 | 韦阳的博客 (godweiyang.com)](https://godweiyang.com/2018/04/13/hexo-blog/)\n- [HEXO系列教程 | 使用GitHub部署静态博客HEXO | 小白向教程 – 夜梦星尘の折腾日记 (yemengstar.com)](https://tech.yemengstar.com/hexo-tutorial-deploy-githubpages-beginner/)\n\n衷心感谢上述博主的分享。","source":"_posts/快速搭建个人博客网站.md","raw":"---\ntitle: 快速搭建个人博客网站\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2024-06-18 12:53:07\npassword:\nsummary:\ntags: git, obsidian, hexo, fluid\ncategories:\n---\n\n# 背景需求\n\n一直在寻找一个合适的平台记录自己的学习笔记、技术开发经验以及日常阅读写作等，尝试了诸多方案，笔记软件类的印象笔记、飞书、Notion、wolai、flomo、obsidian，总觉得少些什么，在封闭的软件中似乎少了一些输出端的监督，后搬运了几篇文章到公众号，但是修改有限制，且引用外部链接不方便。于是乎决定干脆自己搭一个博客网站，考察了很多方案，也参考了很多教程经验，最终选用github+hexo+obdian的框架，主要是因为这三个工具都有一定的使用基础，在学习前端的过程中逐渐熟悉了nodejs，git也是长期在用的版本管理工具，再加上之前也使用了很长一段时间的obsidian做知识管理，有了以上的基础后，便将这个搭建网站这个想法付诸实践。本篇文章主要记录个人搭建博客网站的步骤和参考的教程。\n目前因为经济方面的原因，没有购买域名，暂时借助github pages实现免费托管。\n\n# 安装配置\n网站框架依赖的工具包括hexo、github、obsidian，下面依次介绍这三者的安装配置过程。\n涉及到终端、yml等配置文件的编辑时使用的工具为[vscode](https://code.visualstudio.com/)，也可以使用电脑自带的终端/命令行工具和编辑器。\n## Hexo\n[hexo](https://hexo.io/zh-cn/docs/one-command-deployment)是基于Node.js编写的静态网站生成器，在发布和部署网页时需要用到git分布式管理工具，因此我们需要先安装两个依赖：\n- git\n- Node.js\n### git安装\n到[git官网](https://git-scm.com/download/)下载对应系统版本的安装包或根据官网指引安装。安装完成后在终端输入`git -v`，如果能正确显示git版本说明安装成功。\n### Node.js安装\n首先安装Node.js，到[Node.js官网](https://nodejs.cn/download/)选择下载系统适用的版本，按照安装程序指引一步步安装即可。\n![](image-20240618193622234.png)\n\n安装完成后，在终端中依次输入：\n```bash\nnode -v\nnpm -v\n```\n如果显示node和npm版本，说明正确安装。在安装Node时，会同时安装npm，npm是node的包管理工具。我这里安装的node版本是`v20.13.1`，npm版本是v10.5.2。\n\n![](image-20240618194011460.png)\n### Hexo安装\n使用npm包管理工具安装Hexo，由于npm仓库服务器在国外，下载速度较慢，先修改npm的镜像源为阿里镜像：\n```bash\nnpm config set registry https://registry.npm.taobao.org\n```\n\nnpm有多个安装选项：\n>-S/--save 局部安装，发布到生产环境，写入到package.json文件中的dependencie里\n>-D/--save-dev 局部安装，发布到开发环境， 写入到package.json文件中的devDependencies 里\n>-g 全局安装，安装一次，其他地方也能使用\n\n我们全局安装Hexo\n```bash\nnpm install hexo-cli -g\nhexo -v #打印hexo版本说明安装成功\n```\n![](image-20240618204259093.png)\n\n在本地创建一个文件夹，用于存放你的博客站点文章和配置文件，比如`my-blog`。打开终端输入：\n```bash\nmkdir my-blog && cd my-blog\n#初始化文件夹\nhexo init\n#安装必备的组件\nnpm install\n#生成静态网页\nhexo g\n#打开本地服务器\nhexo s\n```\n执行上述命令后，打开`localhost:8000`即可看到原始的博客网站效果，只有一个Hellow world页面。\n\n## git+github配置\n### git连接配置\n在上一节中，我们安装了git工具，由于我们的网站是借助`Github Pages`托管，所以先去[github](https://github.com/)上注册一个账号，然后连接本地git仓库和远程github仓库，打开终端输入（windows用户打开git bash进行输入）：\n```bash\ngit config --global user.name \"yourname\" #修改为你的github账号名\ngit config --global user.email \"youremail\" #修改为你的github账号邮箱\n```\n配置完成后，可使用如下命令验证能否登录github：\n```bash\nssh -T git@github.com\n```\n按照提示输入用户名和密码后，如果出现以下内容，说明连接成功。\n![](image-20240618210158068.png)\n\n\n在本地生成SSH密钥，用于向远程仓库推送内容。\n```bash\nssh-keygen -t rsa -C \"youremail\"\n\n#生成之后复制SSH公钥\ncat ~/.ssh/id_rsa.pub\n```\n登录github，点击头像-settings，粘贴公钥\n![](image-20240618211935184.png)\n如果github无法登录或访问速度太慢，可参考这篇帖子[如何解决mac无法访问github_mac打不开github-CSDN博客](https://blog.csdn.net/elena_705/article/details/135172231)\n### 新建github.io仓库\n接下来我们新建一个github仓库，点击+号新建仓库。\n![](image-20240618212022198.png)\n注意仓库的名字前缀一定要和你的账户名相同，后缀就是github.io。\n![](image-20240618212413299.png)\n创建完成后，进入仓库，点击settings-pages\n![](image-20240618212456346.png)\n\n![](image-20240618212640334.png)\n使用默认的Branch配置，可以看到对应的`github pages`地址，比如我的是`https://lexieisfree.github.io`。\n\n### 安装`hexo-deployer-git`插件\n安装该插件后我们可以将博客网页内容托管到`Github pages`，就不用时刻在本地运行服务器啦。\n我们在上文创建的博客文件夹（比如我是my-blog）下使用生产环境安装`hexo-deployer-git`插件：\n```bash\nnpm install --save `hexo-deployer-git`\n```\n打开`_config.yml`配置文件添加如下内容：\n```yml\ndeploy: type: git repo: git@github.com:lexieisfree/lexieisfree.github.io.git #修改为你的git仓库地址\nbranch: main   \n```\n\n注意，deploy配置仓库地址一定要用git地址(ssh连接地址), github 2021年8月之后就不支持http密码验证登录。\n\n配置完成后，我们在my-blog（你的博客文件夹下）使用终端运行：\n```bash\nhexo d\n```\n即可将内容部署到github.io仓库中。\n## Fluid主题配置\n我的博客站点使用[fluid](https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97)主题，在生产环境安装`hexo-theme-fluid`\n```bash\nnpm install --save hexo-theme-fluid\n```\n\nHexo 5.0.0 版本以上的用户，在博客目录下创建 `_config.fluid.yml` 文件，将主题配置文件`_config.yml`的全部配置（或部分配置）复制过去。\n\n基本配置可参考：[开始使用 | Hexo Fluid 用户手册 (fluid-dev.com)](https://hexo.fluid-dev.com/docs/start/#%E4%B8%BB%E9%A2%98%E7%AE%80%E4%BB%8B)\n\n- 在`_config.yml`中指定主题\n```yml\ntheme: fluid\n```\n\n- 添加「关于页」\n```bash\n#终端输入\nhexo new page about\n```\n创建成功后修改 `/source/about/index.md`，添加 `layout` 属性。\n\n修改后的文件示例如下：\n\n```\n---\ntitle: 标题\nlayout: about\n---\n\n这里写关于页的正文，支持 Markdown, HTML\n```\n\n- 配置标题（在`_config.fluid.yml`中修改对应内容）\n```yml\n# Site\ntitle: 修改为你的博客标题\nsubtitle: ''\ndescription: ''\nkeywords:\nauthor: 修改为你的名字\nlanguage: zh-CN\ntimezone: ''\n\nnavbar:\n\tblog_title: 修改为你的博客标题\n```\n- 给自己加个slogan\n```yml\nindex:\n\tslogan:\n\t\tenable: true\n\t\ttext: 修改为你的slogan\n\t\tapi:\n\t\tenable: false\n\t\turl: \"https://v1.hitokoto.cn/\"\n\t\tmethod: \"GET\"\n\t\theaders: {}\n\t\tkeys: [\"hitokoto\"]\n```\n\n其他的个性化配置可以参考[fluid官方文档](https://hexo.fluid-dev.com/docs/guide/)\n\n## obsidian配置\n其实这一步不是必要的，只是我个人喜欢用obsidian编辑markdown文档，如果你也想用obsidian编辑你的博客文章可以参考。\nobsidian安装包[下载](https://thoughts.teambition.com/share/62a131711a6baa00416a79d3#title=Obsidian_%E5%AE%89%E8%A3%85%E5%8C%85)\nobsidian的基础用法不再过多赘述，具体可以参考这篇帖子：[PKMer_Obsidian](https://pkmer.cn/Pkmer-Docs/10-obsidian/obsidian/)\n\n在Hexo安装一节中我们创建了一个博客目录my-blog，该目录包含如下文件：\n![](image-20240618223842003.png)\n其中，source文件夹在存放了发布的文章（_posts）和草稿(_drafts)，scaffolds存放模板文件。\n我们使用obsidian打开my-blog/source文件夹。\n\n\n在使用obsidian之前，先安装必要的插件：\n- `PKMer`主要是为了后续安装插件更方便：[PKMer_PKMer 插件主题市场](https://pkmer.cn/products/market/)\n- `custom Attachment Location`： 使用该插件可以在粘贴图片到文章时自动修改图片的存放位置，比如文章的同名文件夹下。\n![](image-20240618222851091.png)\n\n`custom Attachment Location`插件配置：\n\n![](image-20240618223151710.png)\n\n\n# 发布文章\n接下来，就可以愉快地写文章发布啦。\nhexo的使用可参考官方文档：[指令 | Hexo](https://hexo.io/zh-cn/docs/commands)\n\n### 创建博客文章\n终端在博客目录下输入命令：\n```bash\n#创建新博客，执行完成后会在source/_posts文件夹下生成对应的md文档和同名目录\nhexo new post 文章标题  \n\n#创建博客草稿\nhexo new draft 草稿标题\n#草稿发布\nhexo publish 草稿标题\n```\n用obsdian打开source文件夹，编辑文章。\n\n## 生成发布文章\n```bash\nhexo clean #清除缓存\nhexo generate 或 hexo g #生成静态文件\nhexo server 或hexo s #本地运行服务器预览网页\nhexo deploy 或hexo d #静态文件上传到远程服务器\n```\n## 删除文章\n在`my-blog/source/_posts`直接删除文章和对应文件夹（可在obsidian中直接删除）。\n\n重新执行如下命令：\n\n```Bash\nhexo clean\nhexo g\nhexo d  \n```\n# 参考资料\n- [关于我使用obsidian加hexo部署个人博客的过程 - SagiRastar's Blog (sagi-rastar.github.io)](https://sagi-rastar.github.io/2023/11/10/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BD%BF%E7%94%A8obsidian%E5%8A%A0hexo%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B/)\n- [超详细Hexo+Github博客搭建小白教程 | 韦阳的博客 (godweiyang.com)](https://godweiyang.com/2018/04/13/hexo-blog/)\n- [HEXO系列教程 | 使用GitHub部署静态博客HEXO | 小白向教程 – 夜梦星尘の折腾日记 (yemengstar.com)](https://tech.yemengstar.com/hexo-tutorial-deploy-githubpages-beginner/)\n\n衷心感谢上述博主的分享。","slug":"快速搭建个人博客网站","published":1,"updated":"2024-06-20T14:26:07.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly2zhjn5000fxdqre5q2aasf","content":"<h1 id=\"背景需求\"><a href=\"#背景需求\" class=\"headerlink\" title=\"背景需求\"></a>背景需求</h1><p>一直在寻找一个合适的平台记录自己的学习笔记、技术开发经验以及日常阅读写作等，尝试了诸多方案，笔记软件类的印象笔记、飞书、Notion、wolai、flomo、obsidian，总觉得少些什么，在封闭的软件中似乎少了一些输出端的监督，后搬运了几篇文章到公众号，但是修改有限制，且引用外部链接不方便。于是乎决定干脆自己搭一个博客网站，考察了很多方案，也参考了很多教程经验，最终选用github+hexo+obdian的框架，主要是因为这三个工具都有一定的使用基础，在学习前端的过程中逐渐熟悉了nodejs，git也是长期在用的版本管理工具，再加上之前也使用了很长一段时间的obsidian做知识管理，有了以上的基础后，便将这个搭建网站这个想法付诸实践。本篇文章主要记录个人搭建博客网站的步骤和参考的教程。<br>目前因为经济方面的原因，没有购买域名，暂时借助github pages实现免费托管。</p>\n<h1 id=\"安装配置\"><a href=\"#安装配置\" class=\"headerlink\" title=\"安装配置\"></a>安装配置</h1><p>网站框架依赖的工具包括hexo、github、obsidian，下面依次介绍这三者的安装配置过程。<br>涉及到终端、yml等配置文件的编辑时使用的工具为<a href=\"https://code.visualstudio.com/\">vscode</a>，也可以使用电脑自带的终端&#x2F;命令行工具和编辑器。</p>\n<h2 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h2><p><a href=\"https://hexo.io/zh-cn/docs/one-command-deployment\">hexo</a>是基于Node.js编写的静态网站生成器，在发布和部署网页时需要用到git分布式管理工具，因此我们需要先安装两个依赖：</p>\n<ul>\n<li>git</li>\n<li>Node.js</li>\n</ul>\n<h3 id=\"git安装\"><a href=\"#git安装\" class=\"headerlink\" title=\"git安装\"></a>git安装</h3><p>到<a href=\"https://git-scm.com/download/\">git官网</a>下载对应系统版本的安装包或根据官网指引安装。安装完成后在终端输入<code>git -v</code>，如果能正确显示git版本说明安装成功。</p>\n<h3 id=\"Node-js安装\"><a href=\"#Node-js安装\" class=\"headerlink\" title=\"Node.js安装\"></a>Node.js安装</h3><p>首先安装Node.js，到<a href=\"https://nodejs.cn/download/\">Node.js官网</a>选择下载系统适用的版本，按照安装程序指引一步步安装即可。<br><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618193622234.png\"></p>\n<p>安装完成后，在终端中依次输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">node -v<br>npm -v<br></code></pre></td></tr></table></figure>\n<p>如果显示node和npm版本，说明正确安装。在安装Node时，会同时安装npm，npm是node的包管理工具。我这里安装的node版本是<code>v20.13.1</code>，npm版本是v10.5.2。</p>\n<p><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618194011460.png\"></p>\n<h3 id=\"Hexo安装\"><a href=\"#Hexo安装\" class=\"headerlink\" title=\"Hexo安装\"></a>Hexo安装</h3><p>使用npm包管理工具安装Hexo，由于npm仓库服务器在国外，下载速度较慢，先修改npm的镜像源为阿里镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm config <span class=\"hljs-built_in\">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure>\n\n<p>npm有多个安装选项：</p>\n<blockquote>\n<p>-S&#x2F;–save 局部安装，发布到生产环境，写入到package.json文件中的dependencie里<br>-D&#x2F;–save-dev 局部安装，发布到开发环境， 写入到package.json文件中的devDependencies 里<br>-g 全局安装，安装一次，其他地方也能使用</p>\n</blockquote>\n<p>我们全局安装Hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install hexo-cli -g<br>hexo -v <span class=\"hljs-comment\">#打印hexo版本说明安装成功</span><br></code></pre></td></tr></table></figure>\n<p><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618204259093.png\"></p>\n<p>在本地创建一个文件夹，用于存放你的博客站点文章和配置文件，比如<code>my-blog</code>。打开终端输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">mkdir</span> my-blog &amp;&amp; <span class=\"hljs-built_in\">cd</span> my-blog<br><span class=\"hljs-comment\">#初始化文件夹</span><br>hexo init<br><span class=\"hljs-comment\">#安装必备的组件</span><br>npm install<br><span class=\"hljs-comment\">#生成静态网页</span><br>hexo g<br><span class=\"hljs-comment\">#打开本地服务器</span><br>hexo s<br></code></pre></td></tr></table></figure>\n<p>执行上述命令后，打开<code>localhost:8000</code>即可看到原始的博客网站效果，只有一个Hellow world页面。</p>\n<h2 id=\"git-github配置\"><a href=\"#git-github配置\" class=\"headerlink\" title=\"git+github配置\"></a>git+github配置</h2><h3 id=\"git连接配置\"><a href=\"#git连接配置\" class=\"headerlink\" title=\"git连接配置\"></a>git连接配置</h3><p>在上一节中，我们安装了git工具，由于我们的网站是借助<code>Github Pages</code>托管，所以先去<a href=\"https://github.com/\">github</a>上注册一个账号，然后连接本地git仓库和远程github仓库，打开终端输入（windows用户打开git bash进行输入）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config --global user.name <span class=\"hljs-string\">&quot;yourname&quot;</span> <span class=\"hljs-comment\">#修改为你的github账号名</span><br>git config --global user.email <span class=\"hljs-string\">&quot;youremail&quot;</span> <span class=\"hljs-comment\">#修改为你的github账号邮箱</span><br></code></pre></td></tr></table></figure>\n<p>配置完成后，可使用如下命令验证能否登录github：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ssh -T git@github.com<br></code></pre></td></tr></table></figure>\n<p>按照提示输入用户名和密码后，如果出现以下内容，说明连接成功。<br><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618210158068.png\"></p>\n<p>在本地生成SSH密钥，用于向远程仓库推送内容。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ssh-keygen -t rsa -C <span class=\"hljs-string\">&quot;youremail&quot;</span><br><br><span class=\"hljs-comment\">#生成之后复制SSH公钥</span><br><span class=\"hljs-built_in\">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure>\n<p>登录github，点击头像-settings，粘贴公钥<br><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618211935184.png\"><br>如果github无法登录或访问速度太慢，可参考这篇帖子<a href=\"https://blog.csdn.net/elena_705/article/details/135172231\">如何解决mac无法访问github_mac打不开github-CSDN博客</a></p>\n<h3 id=\"新建github-io仓库\"><a href=\"#新建github-io仓库\" class=\"headerlink\" title=\"新建github.io仓库\"></a>新建github.io仓库</h3><p>接下来我们新建一个github仓库，点击+号新建仓库。<br><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618212022198.png\"><br>注意仓库的名字前缀一定要和你的账户名相同，后缀就是github.io。<br><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618212413299.png\"><br>创建完成后，进入仓库，点击settings-pages<br><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618212456346.png\"></p>\n<p><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618212640334.png\"><br>使用默认的Branch配置，可以看到对应的<code>github pages</code>地址，比如我的是<code>https://lexieisfree.github.io</code>。</p>\n<h3 id=\"安装hexo-deployer-git插件\"><a href=\"#安装hexo-deployer-git插件\" class=\"headerlink\" title=\"安装hexo-deployer-git插件\"></a>安装<code>hexo-deployer-git</code>插件</h3><p>安装该插件后我们可以将博客网页内容托管到<code>Github pages</code>，就不用时刻在本地运行服务器啦。<br>我们在上文创建的博客文件夹（比如我是my-blog）下使用生产环境安装<code>hexo-deployer-git</code>插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install --save `hexo-deployer-git`<br></code></pre></td></tr></table></figure>\n<p>打开<code>_config.yml</code>配置文件添加如下内容：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">deploy: type: git repo:</span> <span class=\"hljs-string\">git@github.com:lexieisfree/lexieisfree.github.io.git</span> <span class=\"hljs-comment\">#修改为你的git仓库地址</span><br><span class=\"hljs-attr\">branch:</span> <span class=\"hljs-string\">main</span>   <br></code></pre></td></tr></table></figure>\n\n<p>注意，deploy配置仓库地址一定要用git地址(ssh连接地址), github 2021年8月之后就不支持http密码验证登录。</p>\n<p>配置完成后，我们在my-blog（你的博客文件夹下）使用终端运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo d<br></code></pre></td></tr></table></figure>\n<p>即可将内容部署到github.io仓库中。</p>\n<h2 id=\"Fluid主题配置\"><a href=\"#Fluid主题配置\" class=\"headerlink\" title=\"Fluid主题配置\"></a>Fluid主题配置</h2><p>我的博客站点使用<a href=\"https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97\">fluid</a>主题，在生产环境安装<code>hexo-theme-fluid</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure>\n\n<p>Hexo 5.0.0 版本以上的用户，在博客目录下创建 <code>_config.fluid.yml</code> 文件，将主题配置文件<code>_config.yml</code>的全部配置（或部分配置）复制过去。</p>\n<p>基本配置可参考：<a href=\"https://hexo.fluid-dev.com/docs/start/#%E4%B8%BB%E9%A2%98%E7%AE%80%E4%BB%8B\">开始使用 | Hexo Fluid 用户手册 (fluid-dev.com)</a></p>\n<ul>\n<li><p>在<code>_config.yml</code>中指定主题</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">theme:</span> <span class=\"hljs-string\">fluid</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>添加「关于页」</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#终端输入</span><br>hexo new page about<br></code></pre></td></tr></table></figure>\n<p>创建成功后修改 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p>\n</li>\n</ul>\n<p>修改后的文件示例如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-meta\">---</span><br><span class=\"hljs-attr\">title:</span> <span class=\"hljs-string\">标题</span><br><span class=\"hljs-attr\">layout:</span> <span class=\"hljs-string\">about</span><br><span class=\"hljs-meta\">---</span><br><span class=\"hljs-meta\"></span><br><span class=\"hljs-string\">这里写关于页的正文，支持</span> <span class=\"hljs-string\">Markdown,</span> <span class=\"hljs-string\">HTML</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>配置标题（在<code>_config.fluid.yml</code>中修改对应内容）<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-comment\"># Site</span><br><span class=\"hljs-attr\">title:</span> <span class=\"hljs-string\">修改为你的博客标题</span><br><span class=\"hljs-attr\">subtitle:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br><span class=\"hljs-attr\">description:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br><span class=\"hljs-attr\">keywords:</span><br><span class=\"hljs-attr\">author:</span> <span class=\"hljs-string\">修改为你的名字</span><br><span class=\"hljs-attr\">language:</span> <span class=\"hljs-string\">zh-CN</span><br><span class=\"hljs-attr\">timezone:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br><br><span class=\"hljs-attr\">navbar:</span><br>\t<span class=\"hljs-attr\">blog_title:</span> <span class=\"hljs-string\">修改为你的博客标题</span><br></code></pre></td></tr></table></figure></li>\n<li>给自己加个slogan<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">index:</span><br>\t<span class=\"hljs-attr\">slogan:</span><br>\t\t<span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>\t\t<span class=\"hljs-attr\">text:</span> <span class=\"hljs-string\">修改为你的slogan</span><br>\t\t<span class=\"hljs-attr\">api:</span><br>\t\t<span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br>\t\t<span class=\"hljs-attr\">url:</span> <span class=\"hljs-string\">&quot;https://v1.hitokoto.cn/&quot;</span><br>\t\t<span class=\"hljs-attr\">method:</span> <span class=\"hljs-string\">&quot;GET&quot;</span><br>\t\t<span class=\"hljs-attr\">headers:</span> &#123;&#125;<br>\t\t<span class=\"hljs-attr\">keys:</span> [<span class=\"hljs-string\">&quot;hitokoto&quot;</span>]<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>其他的个性化配置可以参考<a href=\"https://hexo.fluid-dev.com/docs/guide/\">fluid官方文档</a></p>\n<h2 id=\"obsidian配置\"><a href=\"#obsidian配置\" class=\"headerlink\" title=\"obsidian配置\"></a>obsidian配置</h2><p>其实这一步不是必要的，只是我个人喜欢用obsidian编辑markdown文档，如果你也想用obsidian编辑你的博客文章可以参考。<br>obsidian安装包<a href=\"https://thoughts.teambition.com/share/62a131711a6baa00416a79d3#title=Obsidian_%E5%AE%89%E8%A3%85%E5%8C%85\">下载</a><br>obsidian的基础用法不再过多赘述，具体可以参考这篇帖子：<a href=\"https://pkmer.cn/Pkmer-Docs/10-obsidian/obsidian/\">PKMer_Obsidian</a></p>\n<p>在Hexo安装一节中我们创建了一个博客目录my-blog，该目录包含如下文件：<br><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618223842003.png\"><br>其中，source文件夹在存放了发布的文章（_posts）和草稿(_drafts)，scaffolds存放模板文件。<br>我们使用obsidian打开my-blog&#x2F;source文件夹。</p>\n<p>在使用obsidian之前，先安装必要的插件：</p>\n<ul>\n<li><code>PKMer</code>主要是为了后续安装插件更方便：<a href=\"https://pkmer.cn/products/market/\">PKMer_PKMer 插件主题市场</a></li>\n<li><code>custom Attachment Location</code>： 使用该插件可以在粘贴图片到文章时自动修改图片的存放位置，比如文章的同名文件夹下。<br><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618222851091.png\"></li>\n</ul>\n<p><code>custom Attachment Location</code>插件配置：</p>\n<p><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618223151710.png\"></p>\n<h1 id=\"发布文章\"><a href=\"#发布文章\" class=\"headerlink\" title=\"发布文章\"></a>发布文章</h1><p>接下来，就可以愉快地写文章发布啦。<br>hexo的使用可参考官方文档：<a href=\"https://hexo.io/zh-cn/docs/commands\">指令 | Hexo</a></p>\n<h3 id=\"创建博客文章\"><a href=\"#创建博客文章\" class=\"headerlink\" title=\"创建博客文章\"></a>创建博客文章</h3><p>终端在博客目录下输入命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#创建新博客，执行完成后会在source/_posts文件夹下生成对应的md文档和同名目录</span><br>hexo new post 文章标题  <br><br><span class=\"hljs-comment\">#创建博客草稿</span><br>hexo new draft 草稿标题<br><span class=\"hljs-comment\">#草稿发布</span><br>hexo publish 草稿标题<br></code></pre></td></tr></table></figure>\n<p>用obsdian打开source文件夹，编辑文章。</p>\n<h2 id=\"生成发布文章\"><a href=\"#生成发布文章\" class=\"headerlink\" title=\"生成发布文章\"></a>生成发布文章</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo clean <span class=\"hljs-comment\">#清除缓存</span><br>hexo generate 或 hexo g <span class=\"hljs-comment\">#生成静态文件</span><br>hexo server 或hexo s <span class=\"hljs-comment\">#本地运行服务器预览网页</span><br>hexo deploy 或hexo d <span class=\"hljs-comment\">#静态文件上传到远程服务器</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"删除文章\"><a href=\"#删除文章\" class=\"headerlink\" title=\"删除文章\"></a>删除文章</h2><p>在<code>my-blog/source/_posts</code>直接删除文章和对应文件夹（可在obsidian中直接删除）。</p>\n<p>重新执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Bash\">hexo clean<br>hexo g<br>hexo d  <br></code></pre></td></tr></table></figure>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><a href=\"https://sagi-rastar.github.io/2023/11/10/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BD%BF%E7%94%A8obsidian%E5%8A%A0hexo%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B/\">关于我使用obsidian加hexo部署个人博客的过程 - SagiRastar’s Blog (sagi-rastar.github.io)</a></li>\n<li><a href=\"https://godweiyang.com/2018/04/13/hexo-blog/\">超详细Hexo+Github博客搭建小白教程 | 韦阳的博客 (godweiyang.com)</a></li>\n<li><a href=\"https://tech.yemengstar.com/hexo-tutorial-deploy-githubpages-beginner/\">HEXO系列教程 | 使用GitHub部署静态博客HEXO | 小白向教程 – 夜梦星尘の折腾日记 (yemengstar.com)</a></li>\n</ul>\n<p>衷心感谢上述博主的分享。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"背景需求\"><a href=\"#背景需求\" class=\"headerlink\" title=\"背景需求\"></a>背景需求</h1><p>一直在寻找一个合适的平台记录自己的学习笔记、技术开发经验以及日常阅读写作等，尝试了诸多方案，笔记软件类的印象笔记、飞书、Notion、wolai、flomo、obsidian，总觉得少些什么，在封闭的软件中似乎少了一些输出端的监督，后搬运了几篇文章到公众号，但是修改有限制，且引用外部链接不方便。于是乎决定干脆自己搭一个博客网站，考察了很多方案，也参考了很多教程经验，最终选用github+hexo+obdian的框架，主要是因为这三个工具都有一定的使用基础，在学习前端的过程中逐渐熟悉了nodejs，git也是长期在用的版本管理工具，再加上之前也使用了很长一段时间的obsidian做知识管理，有了以上的基础后，便将这个搭建网站这个想法付诸实践。本篇文章主要记录个人搭建博客网站的步骤和参考的教程。<br>目前因为经济方面的原因，没有购买域名，暂时借助github pages实现免费托管。</p>\n<h1 id=\"安装配置\"><a href=\"#安装配置\" class=\"headerlink\" title=\"安装配置\"></a>安装配置</h1><p>网站框架依赖的工具包括hexo、github、obsidian，下面依次介绍这三者的安装配置过程。<br>涉及到终端、yml等配置文件的编辑时使用的工具为<a href=\"https://code.visualstudio.com/\">vscode</a>，也可以使用电脑自带的终端&#x2F;命令行工具和编辑器。</p>\n<h2 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h2><p><a href=\"https://hexo.io/zh-cn/docs/one-command-deployment\">hexo</a>是基于Node.js编写的静态网站生成器，在发布和部署网页时需要用到git分布式管理工具，因此我们需要先安装两个依赖：</p>\n<ul>\n<li>git</li>\n<li>Node.js</li>\n</ul>\n<h3 id=\"git安装\"><a href=\"#git安装\" class=\"headerlink\" title=\"git安装\"></a>git安装</h3><p>到<a href=\"https://git-scm.com/download/\">git官网</a>下载对应系统版本的安装包或根据官网指引安装。安装完成后在终端输入<code>git -v</code>，如果能正确显示git版本说明安装成功。</p>\n<h3 id=\"Node-js安装\"><a href=\"#Node-js安装\" class=\"headerlink\" title=\"Node.js安装\"></a>Node.js安装</h3><p>首先安装Node.js，到<a href=\"https://nodejs.cn/download/\">Node.js官网</a>选择下载系统适用的版本，按照安装程序指引一步步安装即可。<br><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618193622234.png\"></p>\n<p>安装完成后，在终端中依次输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">node -v<br>npm -v<br></code></pre></td></tr></table></figure>\n<p>如果显示node和npm版本，说明正确安装。在安装Node时，会同时安装npm，npm是node的包管理工具。我这里安装的node版本是<code>v20.13.1</code>，npm版本是v10.5.2。</p>\n<p><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618194011460.png\"></p>\n<h3 id=\"Hexo安装\"><a href=\"#Hexo安装\" class=\"headerlink\" title=\"Hexo安装\"></a>Hexo安装</h3><p>使用npm包管理工具安装Hexo，由于npm仓库服务器在国外，下载速度较慢，先修改npm的镜像源为阿里镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm config <span class=\"hljs-built_in\">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure>\n\n<p>npm有多个安装选项：</p>\n<blockquote>\n<p>-S&#x2F;–save 局部安装，发布到生产环境，写入到package.json文件中的dependencie里<br>-D&#x2F;–save-dev 局部安装，发布到开发环境， 写入到package.json文件中的devDependencies 里<br>-g 全局安装，安装一次，其他地方也能使用</p>\n</blockquote>\n<p>我们全局安装Hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install hexo-cli -g<br>hexo -v <span class=\"hljs-comment\">#打印hexo版本说明安装成功</span><br></code></pre></td></tr></table></figure>\n<p><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618204259093.png\"></p>\n<p>在本地创建一个文件夹，用于存放你的博客站点文章和配置文件，比如<code>my-blog</code>。打开终端输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">mkdir</span> my-blog &amp;&amp; <span class=\"hljs-built_in\">cd</span> my-blog<br><span class=\"hljs-comment\">#初始化文件夹</span><br>hexo init<br><span class=\"hljs-comment\">#安装必备的组件</span><br>npm install<br><span class=\"hljs-comment\">#生成静态网页</span><br>hexo g<br><span class=\"hljs-comment\">#打开本地服务器</span><br>hexo s<br></code></pre></td></tr></table></figure>\n<p>执行上述命令后，打开<code>localhost:8000</code>即可看到原始的博客网站效果，只有一个Hellow world页面。</p>\n<h2 id=\"git-github配置\"><a href=\"#git-github配置\" class=\"headerlink\" title=\"git+github配置\"></a>git+github配置</h2><h3 id=\"git连接配置\"><a href=\"#git连接配置\" class=\"headerlink\" title=\"git连接配置\"></a>git连接配置</h3><p>在上一节中，我们安装了git工具，由于我们的网站是借助<code>Github Pages</code>托管，所以先去<a href=\"https://github.com/\">github</a>上注册一个账号，然后连接本地git仓库和远程github仓库，打开终端输入（windows用户打开git bash进行输入）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config --global user.name <span class=\"hljs-string\">&quot;yourname&quot;</span> <span class=\"hljs-comment\">#修改为你的github账号名</span><br>git config --global user.email <span class=\"hljs-string\">&quot;youremail&quot;</span> <span class=\"hljs-comment\">#修改为你的github账号邮箱</span><br></code></pre></td></tr></table></figure>\n<p>配置完成后，可使用如下命令验证能否登录github：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ssh -T git@github.com<br></code></pre></td></tr></table></figure>\n<p>按照提示输入用户名和密码后，如果出现以下内容，说明连接成功。<br><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618210158068.png\"></p>\n<p>在本地生成SSH密钥，用于向远程仓库推送内容。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ssh-keygen -t rsa -C <span class=\"hljs-string\">&quot;youremail&quot;</span><br><br><span class=\"hljs-comment\">#生成之后复制SSH公钥</span><br><span class=\"hljs-built_in\">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure>\n<p>登录github，点击头像-settings，粘贴公钥<br><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618211935184.png\"><br>如果github无法登录或访问速度太慢，可参考这篇帖子<a href=\"https://blog.csdn.net/elena_705/article/details/135172231\">如何解决mac无法访问github_mac打不开github-CSDN博客</a></p>\n<h3 id=\"新建github-io仓库\"><a href=\"#新建github-io仓库\" class=\"headerlink\" title=\"新建github.io仓库\"></a>新建github.io仓库</h3><p>接下来我们新建一个github仓库，点击+号新建仓库。<br><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618212022198.png\"><br>注意仓库的名字前缀一定要和你的账户名相同，后缀就是github.io。<br><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618212413299.png\"><br>创建完成后，进入仓库，点击settings-pages<br><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618212456346.png\"></p>\n<p><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618212640334.png\"><br>使用默认的Branch配置，可以看到对应的<code>github pages</code>地址，比如我的是<code>https://lexieisfree.github.io</code>。</p>\n<h3 id=\"安装hexo-deployer-git插件\"><a href=\"#安装hexo-deployer-git插件\" class=\"headerlink\" title=\"安装hexo-deployer-git插件\"></a>安装<code>hexo-deployer-git</code>插件</h3><p>安装该插件后我们可以将博客网页内容托管到<code>Github pages</code>，就不用时刻在本地运行服务器啦。<br>我们在上文创建的博客文件夹（比如我是my-blog）下使用生产环境安装<code>hexo-deployer-git</code>插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install --save `hexo-deployer-git`<br></code></pre></td></tr></table></figure>\n<p>打开<code>_config.yml</code>配置文件添加如下内容：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">deploy: type: git repo:</span> <span class=\"hljs-string\">git@github.com:lexieisfree/lexieisfree.github.io.git</span> <span class=\"hljs-comment\">#修改为你的git仓库地址</span><br><span class=\"hljs-attr\">branch:</span> <span class=\"hljs-string\">main</span>   <br></code></pre></td></tr></table></figure>\n\n<p>注意，deploy配置仓库地址一定要用git地址(ssh连接地址), github 2021年8月之后就不支持http密码验证登录。</p>\n<p>配置完成后，我们在my-blog（你的博客文件夹下）使用终端运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo d<br></code></pre></td></tr></table></figure>\n<p>即可将内容部署到github.io仓库中。</p>\n<h2 id=\"Fluid主题配置\"><a href=\"#Fluid主题配置\" class=\"headerlink\" title=\"Fluid主题配置\"></a>Fluid主题配置</h2><p>我的博客站点使用<a href=\"https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97\">fluid</a>主题，在生产环境安装<code>hexo-theme-fluid</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure>\n\n<p>Hexo 5.0.0 版本以上的用户，在博客目录下创建 <code>_config.fluid.yml</code> 文件，将主题配置文件<code>_config.yml</code>的全部配置（或部分配置）复制过去。</p>\n<p>基本配置可参考：<a href=\"https://hexo.fluid-dev.com/docs/start/#%E4%B8%BB%E9%A2%98%E7%AE%80%E4%BB%8B\">开始使用 | Hexo Fluid 用户手册 (fluid-dev.com)</a></p>\n<ul>\n<li><p>在<code>_config.yml</code>中指定主题</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">theme:</span> <span class=\"hljs-string\">fluid</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>添加「关于页」</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#终端输入</span><br>hexo new page about<br></code></pre></td></tr></table></figure>\n<p>创建成功后修改 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p>\n</li>\n</ul>\n<p>修改后的文件示例如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-meta\">---</span><br><span class=\"hljs-attr\">title:</span> <span class=\"hljs-string\">标题</span><br><span class=\"hljs-attr\">layout:</span> <span class=\"hljs-string\">about</span><br><span class=\"hljs-meta\">---</span><br><span class=\"hljs-meta\"></span><br><span class=\"hljs-string\">这里写关于页的正文，支持</span> <span class=\"hljs-string\">Markdown,</span> <span class=\"hljs-string\">HTML</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>配置标题（在<code>_config.fluid.yml</code>中修改对应内容）<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-comment\"># Site</span><br><span class=\"hljs-attr\">title:</span> <span class=\"hljs-string\">修改为你的博客标题</span><br><span class=\"hljs-attr\">subtitle:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br><span class=\"hljs-attr\">description:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br><span class=\"hljs-attr\">keywords:</span><br><span class=\"hljs-attr\">author:</span> <span class=\"hljs-string\">修改为你的名字</span><br><span class=\"hljs-attr\">language:</span> <span class=\"hljs-string\">zh-CN</span><br><span class=\"hljs-attr\">timezone:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br><br><span class=\"hljs-attr\">navbar:</span><br>\t<span class=\"hljs-attr\">blog_title:</span> <span class=\"hljs-string\">修改为你的博客标题</span><br></code></pre></td></tr></table></figure></li>\n<li>给自己加个slogan<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">index:</span><br>\t<span class=\"hljs-attr\">slogan:</span><br>\t\t<span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>\t\t<span class=\"hljs-attr\">text:</span> <span class=\"hljs-string\">修改为你的slogan</span><br>\t\t<span class=\"hljs-attr\">api:</span><br>\t\t<span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br>\t\t<span class=\"hljs-attr\">url:</span> <span class=\"hljs-string\">&quot;https://v1.hitokoto.cn/&quot;</span><br>\t\t<span class=\"hljs-attr\">method:</span> <span class=\"hljs-string\">&quot;GET&quot;</span><br>\t\t<span class=\"hljs-attr\">headers:</span> &#123;&#125;<br>\t\t<span class=\"hljs-attr\">keys:</span> [<span class=\"hljs-string\">&quot;hitokoto&quot;</span>]<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>其他的个性化配置可以参考<a href=\"https://hexo.fluid-dev.com/docs/guide/\">fluid官方文档</a></p>\n<h2 id=\"obsidian配置\"><a href=\"#obsidian配置\" class=\"headerlink\" title=\"obsidian配置\"></a>obsidian配置</h2><p>其实这一步不是必要的，只是我个人喜欢用obsidian编辑markdown文档，如果你也想用obsidian编辑你的博客文章可以参考。<br>obsidian安装包<a href=\"https://thoughts.teambition.com/share/62a131711a6baa00416a79d3#title=Obsidian_%E5%AE%89%E8%A3%85%E5%8C%85\">下载</a><br>obsidian的基础用法不再过多赘述，具体可以参考这篇帖子：<a href=\"https://pkmer.cn/Pkmer-Docs/10-obsidian/obsidian/\">PKMer_Obsidian</a></p>\n<p>在Hexo安装一节中我们创建了一个博客目录my-blog，该目录包含如下文件：<br><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618223842003.png\"><br>其中，source文件夹在存放了发布的文章（_posts）和草稿(_drafts)，scaffolds存放模板文件。<br>我们使用obsidian打开my-blog&#x2F;source文件夹。</p>\n<p>在使用obsidian之前，先安装必要的插件：</p>\n<ul>\n<li><code>PKMer</code>主要是为了后续安装插件更方便：<a href=\"https://pkmer.cn/products/market/\">PKMer_PKMer 插件主题市场</a></li>\n<li><code>custom Attachment Location</code>： 使用该插件可以在粘贴图片到文章时自动修改图片的存放位置，比如文章的同名文件夹下。<br><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618222851091.png\"></li>\n</ul>\n<p><code>custom Attachment Location</code>插件配置：</p>\n<p><img src=\"/2024/06/18/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/image-20240618223151710.png\"></p>\n<h1 id=\"发布文章\"><a href=\"#发布文章\" class=\"headerlink\" title=\"发布文章\"></a>发布文章</h1><p>接下来，就可以愉快地写文章发布啦。<br>hexo的使用可参考官方文档：<a href=\"https://hexo.io/zh-cn/docs/commands\">指令 | Hexo</a></p>\n<h3 id=\"创建博客文章\"><a href=\"#创建博客文章\" class=\"headerlink\" title=\"创建博客文章\"></a>创建博客文章</h3><p>终端在博客目录下输入命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#创建新博客，执行完成后会在source/_posts文件夹下生成对应的md文档和同名目录</span><br>hexo new post 文章标题  <br><br><span class=\"hljs-comment\">#创建博客草稿</span><br>hexo new draft 草稿标题<br><span class=\"hljs-comment\">#草稿发布</span><br>hexo publish 草稿标题<br></code></pre></td></tr></table></figure>\n<p>用obsdian打开source文件夹，编辑文章。</p>\n<h2 id=\"生成发布文章\"><a href=\"#生成发布文章\" class=\"headerlink\" title=\"生成发布文章\"></a>生成发布文章</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo clean <span class=\"hljs-comment\">#清除缓存</span><br>hexo generate 或 hexo g <span class=\"hljs-comment\">#生成静态文件</span><br>hexo server 或hexo s <span class=\"hljs-comment\">#本地运行服务器预览网页</span><br>hexo deploy 或hexo d <span class=\"hljs-comment\">#静态文件上传到远程服务器</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"删除文章\"><a href=\"#删除文章\" class=\"headerlink\" title=\"删除文章\"></a>删除文章</h2><p>在<code>my-blog/source/_posts</code>直接删除文章和对应文件夹（可在obsidian中直接删除）。</p>\n<p>重新执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Bash\">hexo clean<br>hexo g<br>hexo d  <br></code></pre></td></tr></table></figure>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><a href=\"https://sagi-rastar.github.io/2023/11/10/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BD%BF%E7%94%A8obsidian%E5%8A%A0hexo%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B/\">关于我使用obsidian加hexo部署个人博客的过程 - SagiRastar’s Blog (sagi-rastar.github.io)</a></li>\n<li><a href=\"https://godweiyang.com/2018/04/13/hexo-blog/\">超详细Hexo+Github博客搭建小白教程 | 韦阳的博客 (godweiyang.com)</a></li>\n<li><a href=\"https://tech.yemengstar.com/hexo-tutorial-deploy-githubpages-beginner/\">HEXO系列教程 | 使用GitHub部署静态博客HEXO | 小白向教程 – 夜梦星尘の折腾日记 (yemengstar.com)</a></li>\n</ul>\n<p>衷心感谢上述博主的分享。</p>\n"}],"PostAsset":[{"_id":"source/_posts/了解cookie-session-token/image-20240701133048798.png","post":"cly2zhjn3000cxdqr2qy180q8","slug":"image-20240701133048798.png","modified":1,"renderable":1},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618193622234.png","post":"cly2zhjn5000fxdqre5q2aasf","slug":"image-20240618193622234.png","modified":1,"renderable":1},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618194011460.png","post":"cly2zhjn5000fxdqre5q2aasf","slug":"image-20240618194011460.png","modified":1,"renderable":1},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618204259093.png","post":"cly2zhjn5000fxdqre5q2aasf","slug":"image-20240618204259093.png","modified":1,"renderable":1},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618210158068.png","post":"cly2zhjn5000fxdqre5q2aasf","slug":"image-20240618210158068.png","modified":1,"renderable":1},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618211935184.png","post":"cly2zhjn5000fxdqre5q2aasf","slug":"image-20240618211935184.png","modified":1,"renderable":1},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618212022198.png","post":"cly2zhjn5000fxdqre5q2aasf","slug":"image-20240618212022198.png","modified":1,"renderable":1},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618212206448.png","post":"cly2zhjn5000fxdqre5q2aasf","slug":"image-20240618212206448.png","modified":1,"renderable":1},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618212413299.png","post":"cly2zhjn5000fxdqre5q2aasf","slug":"image-20240618212413299.png","modified":1,"renderable":1},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618212456346.png","post":"cly2zhjn5000fxdqre5q2aasf","slug":"image-20240618212456346.png","modified":1,"renderable":1},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618212640334.png","post":"cly2zhjn5000fxdqre5q2aasf","slug":"image-20240618212640334.png","modified":1,"renderable":1},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618222851091.png","post":"cly2zhjn5000fxdqre5q2aasf","slug":"image-20240618222851091.png","modified":1,"renderable":1},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618223151710.png","post":"cly2zhjn5000fxdqre5q2aasf","slug":"image-20240618223151710.png","modified":1,"renderable":1},{"_id":"source/_posts/快速搭建个人博客网站/image-20240618223842003.png","post":"cly2zhjn5000fxdqre5q2aasf","slug":"image-20240618223842003.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cly2zhjmy0003xdqr6lyj1pm0","tag_id":"cly2zhjn00005xdqr3db8huwl","_id":"cly2zhjn10008xdqr4492b611"},{"post_id":"cly2zhjmy0003xdqr6lyj1pm0","tag_id":"cly2zhjn10006xdqrfq61gpxj","_id":"cly2zhjn10009xdqrcqv3a22l"},{"post_id":"cly2zhjmz0004xdqrfeor4dvb","tag_id":"cly2zhjn10007xdqrgr6helb6","_id":"cly2zhjn1000axdqrcl4dcf30"},{"post_id":"cly2zhjn3000bxdqredmp0f5x","tag_id":"cly2zhjn4000dxdqr6yqi11bh","_id":"cly2zhjn5000hxdqr0lsb04di"},{"post_id":"cly2zhjn3000cxdqr2qy180q8","tag_id":"cly2zhjn5000gxdqr2idy3g2c","_id":"cly2zhjn5000jxdqr4a5n6mcu"},{"post_id":"cly2zhjn4000exdqr3j6t006e","tag_id":"cly2zhjn5000ixdqrct84cy6x","_id":"cly2zhjn6000mxdqr0jka69gv"},{"post_id":"cly2zhjn4000exdqr3j6t006e","tag_id":"cly2zhjn6000kxdqr550c4529","_id":"cly2zhjn6000nxdqr6uqk1sjk"},{"post_id":"cly2zhjn5000fxdqre5q2aasf","tag_id":"cly2zhjn6000lxdqrft1f04ef","_id":"cly2zhjn6000oxdqrbk8h3a7i"}],"Tag":[{"name":"kafka","_id":"cly2zhjn00005xdqr3db8huwl"},{"name":"系统架构","_id":"cly2zhjn10006xdqrfq61gpxj"},{"name":"ffmpeg","_id":"cly2zhjn10007xdqrgr6helb6"},{"name":"javascript, python, 单线程, 异步","_id":"cly2zhjn4000dxdqr6yqi11bh"},{"name":"web","_id":"cly2zhjn5000gxdqr2idy3g2c"},{"name":"gis","_id":"cly2zhjn5000ixdqrct84cy6x"},{"name":"python","_id":"cly2zhjn6000kxdqr550c4529"},{"name":"git, obsidian, hexo, fluid","_id":"cly2zhjn6000lxdqrft1f04ef"}]}}